"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/app-find-source-map-url.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findSourceMapURL\", ({\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n}));\nconst basePath =  false || '';\nconst pathname = \"\" + basePath + \"/__nextjs_source-map\";\nconst findSourceMapURL =  true ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return \"\" + filename + \".map\";\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-find-source-map-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7b0RBR2FBOzs7ZUFBQUE7OztBQUhiLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsTUFBTUcsV0FBWSxLQUFFSixXQUFTO0FBRXRCLE1BQU1ELG1CQUNYRSxLQUFvQixHQUNoQixTQUFTRixpQkFBaUJPLFFBQWdCO0lBQ3hDLElBQUlBLGFBQWEsSUFBSTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxJQUNFQSxTQUFTQyxVQUFVLENBQUNDLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTSxLQUM1Q0osU0FBU0ssUUFBUSxDQUFDLGtCQUNsQjtRQUNBLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsNERBQTREO1FBQzVELDZDQUE2QztRQUM3QyxPQUFRLEtBQUVMLFdBQVM7SUFDckI7SUFFQSxNQUFNTSxNQUFNLElBQUlDLElBQUlULFVBQVVJLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTTtJQUN0REUsSUFBSUUsWUFBWSxDQUFDQyxHQUFHLENBQUMsWUFBWVQ7SUFFakMsT0FBT00sSUFBSUksSUFBSTtBQUNqQixJQUNBQyxDQUFTQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxFZHVhcmRvXFxEZXNrdG9wXFxzcmNcXGNsaWVudFxcYXBwLWZpbmQtc291cmNlLW1hcC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnXG5jb25zdCBwYXRobmFtZSA9IGAke2Jhc2VQYXRofS9fX25leHRqc19zb3VyY2UtbWFwYFxuXG5leHBvcnQgY29uc3QgZmluZFNvdXJjZU1hcFVSTCA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgPyBmdW5jdGlvbiBmaW5kU291cmNlTWFwVVJMKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pICYmXG4gICAgICAgICAgZmlsZW5hbWUuaW5jbHVkZXMoJy9fbmV4dC9zdGF0aWMnKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVxdWVzdCBmb3IgYSBjbGllbnQgY2h1bmsuIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdoZW5cbiAgICAgICAgICAvLyB1c2luZyBUdXJib3BhY2suIEluIHRoaXMgY2FzZSwgc2luY2Ugd2UgY29udHJvbCBob3cgdGhvc2Ugc291cmNlXG4gICAgICAgICAgLy8gbWFwcyBhcmUgZ2VuZXJhdGVkLCB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0IHRoZSBzb3VyY2VNYXBwaW5nVVJMXG4gICAgICAgICAgLy8gaXMgcmVsYXRpdmUgdG8gdGhlIGZpbGVuYW1lLCB3aXRoIGFuIGFkZGVkIGAubWFwYCBleHRlbnNpb24uIFRoZVxuICAgICAgICAgIC8vIGJyb3dzZXIgY2FuIGp1c3QgcmVxdWVzdCB0aGlzIGZpbGUsIGFuZCBpdCBnZXRzIHNlcnZlZCB0aHJvdWdoIHRoZVxuICAgICAgICAgIC8vIG5vcm1hbCBkZXYgc2VydmVyLCB3aXRob3V0IHRoZSBuZWVkIHRvIHJvdXRlIHRoaXMgdGhyb3VnaFxuICAgICAgICAgIC8vIHRoZSBgL19fbmV4dGpzX3NvdXJjZS1tYXBgIGRldiBtaWRkbGV3YXJlLlxuICAgICAgICAgIHJldHVybiBgJHtmaWxlbmFtZX0ubWFwYFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRobmFtZSwgZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luKVxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZmlsZW5hbWUnLCBmaWxlbmFtZSlcblxuICAgICAgICByZXR1cm4gdXJsLmhyZWZcbiAgICAgIH1cbiAgICA6IHVuZGVmaW5lZFxuIl0sIm5hbWVzIjpbImZpbmRTb3VyY2VNYXBVUkwiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aG5hbWUiLCJOT0RFX0VOViIsImZpbGVuYW1lIiwic3RhcnRzV2l0aCIsImRvY3VtZW50IiwibG9jYXRpb24iLCJvcmlnaW4iLCJpbmNsdWRlcyIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsImhyZWYiLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/app-link-gc.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            var _link_dataset_precedence;\n                            const link = node;\n                            if ((_link_dataset_precedence = link.dataset.precedence) == null ? void 0 : _link_dataset_precedence.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            var _otherLink_dataset_precedence;\n                                            if ((_otherLink_dataset_precedence = otherLink.dataset.precedence) == null ? void 0 : _otherLink_dataset_precedence.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector('link[rel=\"preload\"][as=\"style\"][href=\"' + otherHref + '\"]');\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1saW5rLWdjLmpzIiwibWFwcGluZ3MiOiI7Ozs7MENBQWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQTtJQUNkLHlFQUF5RTtJQUN6RSxJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNRyxXQUFXLENBQUNDO1lBQ2hCLEtBQUssTUFBTUMsWUFBWUQsYUFBYztnQkFDbkMsSUFBSUMsU0FBU0MsSUFBSSxLQUFLLGFBQWE7b0JBQ2pDLEtBQUssTUFBTUMsUUFBUUYsU0FBU0csVUFBVSxDQUFFO3dCQUN0QyxJQUNFLGFBQWFELFFBQ1pBLEtBQXlCRSxPQUFPLEtBQUssUUFDdEM7Z0NBRUlDOzRCQURKLE1BQU1BLE9BQU9IOzRCQUNiLEtBQUlHLDJCQUFBQSxLQUFLQyxPQUFPLENBQUNDLFVBQUFBLEtBQVUsZ0JBQXZCRix5QkFBeUJHLFVBQVUsQ0FBQyxTQUFTO2dDQUMvQyxNQUFNQyxPQUFPSixLQUFLSyxZQUFZLENBQUM7Z0NBQy9CLElBQUlELE1BQU07b0NBQ1IsTUFBTSxDQUFDRSxVQUFVQyxRQUFRLEdBQUdILEtBQUtJLEtBQUssQ0FBQyxPQUFPO29DQUM5QyxJQUFJRCxTQUFTO3dDQUNYLE1BQU1FLGdCQUFnQkMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO3dDQUM1QyxNQUFNQyxXQUFXOytDQUNaQyxTQUFTQyxnQkFBZ0IsQ0FDMUIsaUJBQWlCVCxXQUFXOzRDQUU5QixrRUFBa0U7NENBQ2xFLHFEQUFxRDsrQ0FDbERRLFNBQVNDLGdCQUFnQixDQUMxQixpQkFDR1QsQ0FBQUEsU0FBU0gsVUFBVSxDQUFDTSxpQkFDakJILFNBQVNVLEtBQUssQ0FBQ1AsY0FBY1EsTUFBTSxJQUNuQ1IsZ0JBQWdCSCxRQUFBQSxDQUFPLEdBQzNCO3lDQUVMO3dDQUVELEtBQUssTUFBTVksYUFBYUwsU0FBVTtnREFDNUJLOzRDQUFKLEtBQUlBLGdDQUFBQSxVQUFVakIsT0FBTyxDQUFDQyxVQUFBQSxLQUFVLGdCQUE1QmdCLDhCQUE4QmYsVUFBVSxDQUFDLFNBQVM7Z0RBQ3BELE1BQU1nQixZQUFZRCxVQUFVYixZQUFZLENBQUM7Z0RBQ3pDLElBQUljLFdBQVc7b0RBQ2IsTUFBTSxHQUFHQyxhQUFhLEdBQUdELFVBQVVYLEtBQUssQ0FBQyxPQUFPO29EQUNoRCxJQUFJLENBQUNZLGdCQUFnQixDQUFDQSxlQUFlLENBQUNiLFNBQVM7d0RBQzdDLG9EQUFvRDt3REFDcEQsbURBQW1EO3dEQUNuRCxvREFBb0Q7d0RBQ3BELG1EQUFtRDt3REFDbkRjLFdBQVc7NERBQ1RILFVBQVVJLE1BQU07d0RBQ2xCLEdBQUc7d0RBQ0gsTUFBTUMsY0FBY1QsU0FBU1UsYUFBYSxDQUN2QywyQ0FBd0NMLFlBQVU7d0RBRXJELElBQUlJLGFBQWE7NERBQ2ZBLFlBQVlELE1BQU07d0RBQ3BCO29EQUNGO2dEQUNGOzRDQUNGO3dDQUNGO29DQUNGO2dDQUNGOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDhEQUE4RDtRQUM5RCxNQUFNRyxXQUFXLElBQUlDLGlCQUFpQmpDO1FBQ3RDZ0MsU0FBU0UsT0FBTyxDQUFDYixTQUFTYyxJQUFJLEVBQUU7WUFDOUJDLFdBQVc7UUFDYjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRWR1YXJkb1xcRGVza3RvcFxcc3JjXFxjbGllbnRcXGFwcC1saW5rLWdjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBsaW5rR2MoKSB7XG4gIC8vIFRPRE8tQVBQOiBSZW1vdmUgdGhpcyBsb2dpYyB3aGVuIEZsb2F0IGhhcyBHQyBidWlsdC1pbiBpbiBkZXZlbG9wbWVudC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IChtdXRhdGlvbkxpc3Q6IE11dGF0aW9uUmVjb3JkW10pID0+IHtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25MaXN0KSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICd0YWdOYW1lJyBpbiBub2RlICYmXG4gICAgICAgICAgICAgIChub2RlIGFzIEhUTUxMaW5rRWxlbWVudCkudGFnTmFtZSA9PT0gJ0xJTksnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluayA9IG5vZGUgYXMgSFRNTExpbmtFbGVtZW50XG4gICAgICAgICAgICAgIGlmIChsaW5rLmRhdGFzZXQucHJlY2VkZW5jZT8uc3RhcnRzV2l0aCgnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgW3Jlc291cmNlLCB2ZXJzaW9uXSA9IGhyZWYuc3BsaXQoJz92PScsIDIpXG4gICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50T3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxMaW5rcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmtbaHJlZl49XCInICsgcmVzb3VyY2UgKyAnXCJdJ1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSByZXNvdXJjZSBpcyBhIGZ1bGwgVVJMIG9yIG9ubHkgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byByZW1vdmUgdGhlIGFsdGVybmF0aXZlIGhyZWYgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmtbaHJlZl49XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc291cmNlLnN0YXJ0c1dpdGgoY3VycmVudE9yaWdpbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc291cmNlLnNsaWNlKGN1cnJlbnRPcmlnaW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudE9yaWdpbiArIHJlc291cmNlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdcIl0nXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXSBhcyBIVE1MTGlua0VsZW1lbnRbXVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3RoZXJMaW5rIG9mIGFsbExpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyTGluay5kYXRhc2V0LnByZWNlZGVuY2U/LnN0YXJ0c1dpdGgoJ25leHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJIcmVmID0gb3RoZXJMaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIG90aGVyVmVyc2lvbl0gPSBvdGhlckhyZWYuc3BsaXQoJz92PScsIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJWZXJzaW9uIHx8ICtvdGhlclZlcnNpb24gPCArdmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZW1vdmFsIG9mIHRoZSBzdHlsZXNoZWV0IHRvIGF2b2lkIEZPVUNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXVzZWQgYnkgYEBmb250LWZhY2VgIHJ1bGVzLCBhcyB0aGV5IHNlZW0gdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNvdXBsZSBvZiB0aWNrcyBkZWxheWVkIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIGJlaW5nIHN3YXBwZWQgZXZlbiBpZiB0aGUgZm9udCBpcyBjYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckxpbmsucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRMaW5rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBsaW5rW3JlbD1cInByZWxvYWRcIl1bYXM9XCJzdHlsZVwiXVtocmVmPVwiJHtvdGhlckhyZWZ9XCJdYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlbG9hZExpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWxvYWRMaW5rLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGxpbmtlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKVxuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuaGVhZCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIH0pXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJsaW5rR2MiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjYWxsYmFjayIsIm11dGF0aW9uTGlzdCIsIm11dGF0aW9uIiwidHlwZSIsIm5vZGUiLCJhZGRlZE5vZGVzIiwidGFnTmFtZSIsImxpbmsiLCJkYXRhc2V0IiwicHJlY2VkZW5jZSIsInN0YXJ0c1dpdGgiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwicmVzb3VyY2UiLCJ2ZXJzaW9uIiwic3BsaXQiLCJjdXJyZW50T3JpZ2luIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJhbGxMaW5rcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsInNsaWNlIiwibGVuZ3RoIiwib3RoZXJMaW5rIiwib3RoZXJIcmVmIiwib3RoZXJWZXJzaW9uIiwic2V0VGltZW91dCIsInJlbW92ZSIsInByZWxvYWRMaW5rIiwicXVlcnlTZWxlY3RvciIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJoZWFkIiwiY2hpbGRMaXN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEmptyCacheNode: function() {\n        return createEmptyCacheNode;\n    },\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    default: function() {\n        return AppRouter;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _usereducer = __webpack_require__(/*! ./use-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-reducer.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _appcallserver = __webpack_require__(/*! ../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _prefetch = __webpack_require__(/*! ../components/segment-cache/prefetch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache/prefetch.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst globalMutable = {};\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw new Error(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\");\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nfunction HistoryUpdater(param) {\n    let { appRouterState } = param;\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl } = appRouterState;\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: tree\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction createEmptyCacheNode() {\n    return {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null\n    };\n}\n/**\n * Server response that only patches the cache and tree.\n */ function useChangeByServerResponse(dispatch) {\n    return (0, _react.useCallback)((param)=>{\n        let { previousTree, serverResponse } = param;\n        (0, _react.startTransition)(()=>{\n            dispatch({\n                type: _routerreducertypes.ACTION_SERVER_PATCH,\n                previousTree,\n                serverResponse\n            });\n        });\n    }, [\n        dispatch\n    ]);\n}\nfunction useNavigate(dispatch) {\n    return (0, _react.useCallback)((href, navigateType, shouldScroll)=>{\n        const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n        if (false) {}\n        return dispatch({\n            type: _routerreducertypes.ACTION_NAVIGATE,\n            url,\n            isExternalUrl: isExternalURL(url),\n            locationSearch: location.search,\n            shouldScroll: shouldScroll != null ? shouldScroll : true,\n            navigateType,\n            allowAliasing: true\n        });\n    }, [\n        dispatch\n    ]);\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState == null ? void 0 : currentState.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head(param) {\n    let { headCacheNode } = param;\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    //\n    // @ts-expect-error The second argument to `useDeferredValue` is only\n    // available in the experimental builds. When its disabled, it will always\n    // return `head`.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    _s();\n    let { actionQueue, assetPrefix } = param;\n    const [state, dispatch] = (0, _usereducer.useReducer)(actionQueue);\n    const { canonicalUrl } = (0, _usereducer.useUnwrapState)(state);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl, typeof window === 'undefined' ? 'http://n' : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    const changeByServerResponse = useChangeByServerResponse(dispatch);\n    const navigate = useNavigate(dispatch);\n    (0, _appcallserver.useServerActionDispatcher)(dispatch);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react.useMemo)(()=>{\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            prefetch:  false ? // cache. So we don't need to dispatch an action.\n            0 : (href, options)=>{\n                // Use the old prefetch implementation.\n                const url = createPrefetchURL(href);\n                if (url !== null) {\n                    (0, _react.startTransition)(()=>{\n                        var _options_kind;\n                        dispatch({\n                            type: _routerreducertypes.ACTION_PREFETCH,\n                            url,\n                            kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL\n                        });\n                    });\n                }\n            },\n            replace: (href, options)=>{\n                if (options === void 0) options = {};\n                (0, _react.startTransition)(()=>{\n                    var _options_scroll;\n                    navigate(href, 'replace', (_options_scroll = options.scroll) != null ? _options_scroll : true);\n                });\n            },\n            push: (href, options)=>{\n                if (options === void 0) options = {};\n                (0, _react.startTransition)(()=>{\n                    var _options_scroll;\n                    navigate(href, 'push', (_options_scroll = options.scroll) != null ? _options_scroll : true);\n                });\n            },\n            refresh: ()=>{\n                (0, _react.startTransition)(()=>{\n                    dispatch({\n                        type: _routerreducertypes.ACTION_REFRESH,\n                        origin: window.location.origin\n                    });\n                });\n            },\n            hmrRefresh: ()=>{\n                if (false) {} else {\n                    (0, _react.startTransition)(()=>{\n                        dispatch({\n                            type: _routerreducertypes.ACTION_HMR_REFRESH,\n                            origin: window.location.origin\n                        });\n                    });\n                }\n            }\n        };\n        return routerInstance;\n    }, [\n        actionQueue,\n        dispatch,\n        navigate\n    ]);\n    (0, _react.useEffect)(()=>{\n        // Exists for debugging purposes. Don't use in application code.\n        if (window.next) {\n            window.next.router = appRouter;\n        }\n    }, [\n        appRouter\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const { cache, prefetchCache, tree } = (0, _usereducer.useUnwrapState)(state);\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: appRouter,\n                cache,\n                prefetchCache,\n                tree\n            };\n        }, [\n            appRouter,\n            cache,\n            prefetchCache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            var _window_history_state;\n            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            dispatch({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, [\n        dispatch\n    ]);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    appRouter.push(url, {});\n                } else {\n                    appRouter.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, [\n        appRouter\n    ]);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = (0, _usereducer.useUnwrapState)(state);\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location1 = window.location;\n            if (pushRef.pendingPush) {\n                location1.assign(canonicalUrl);\n            } else {\n                location1.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            var _window_history_state;\n            const href = window.location.href;\n            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                dispatch({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url != null ? url : href, href),\n                    tree\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                dispatch({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(window.location.href),\n                    tree: event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n                });\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, [\n        dispatch\n    ]);\n    const { cache, tree, nextUrl, focusAndScrollRef } = (0, _usereducer.useUnwrapState)(state);\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            childNodes: cache.parallelRoutes,\n            tree,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            loading: cache.loading\n        };\n    }, [\n        cache.parallelRoutes,\n        tree,\n        canonicalUrl,\n        cache.loading\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef,\n            nextUrl\n        };\n    }, [\n        changeByServerResponse,\n        tree,\n        focusAndScrollRef,\n        nextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        }, headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            cache.rsc,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        if (typeof window !== 'undefined') {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ./react-dev-overlay/app/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            assetPrefix: assetPrefix,\n            children: content\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: (0, _usereducer.useUnwrapState)(state)\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                value: pathParams,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                    value: pathname,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                        value: searchParams,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                            value: globalLayoutRouterContext,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                value: appRouter,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                    value: layoutRouterContext,\n                                    children: content\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_s(Router, \"bU8t8nCPb2ycaFr1siwKA2Gych0=\", false, function() {\n    return [\n        useChangeByServerResponse,\n        useNavigate\n    ];\n});\n_c2 = Router;\nfunction AppRouter(param) {\n    let { actionQueue, globalErrorComponentAndStyles: [globalErrorComponent, globalErrorStyles], assetPrefix } = param;\n    (0, _navfailurehandler.useNavFailureHandler)();\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n        errorComponent: globalErrorComponent,\n        errorStyles: globalErrorStyles,\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n            actionQueue: actionQueue,\n            assetPrefix: assetPrefix\n        })\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s1();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId =  false ? 0 : '';\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: \"\" + href + dplId,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s1(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQThJZ0JBLG9CQUFvQjtlQUFwQkE7O0lBbkVBQyxpQkFBaUI7ZUFBakJBOztJQTBqQmhCLE9BbUJDO2VBbkJ1QkM7Ozs7OzZFQTNuQmpCOzJEQUtBO2dEQWFBOytDQU8yQjs2REFLM0I7d0NBQ29DOzJDQUNRO21DQUM3Qjt5Q0FDTTtnREFDTzs4Q0FDRjs2Q0FDRDtnREFDRzs0Q0FDSjt5Q0FDSDtnREFDTTsrQ0FFRzsyQ0FDSztzQ0FFVztzQ0FDYTsyQ0FDcEI7QUFFOUMsTUFBTUMsZ0JBRUYsQ0FBQztBQUVMLFNBQVNDLGNBQWNDLEdBQVE7SUFDN0IsT0FBT0EsSUFBSUMsTUFBTSxLQUFLQyxPQUFPQyxRQUFRLENBQUNGLE1BQU07QUFDOUM7QUFTTyxTQUFTTCxrQkFBa0JRLElBQVk7SUFDNUMsa0RBQWtEO0lBQ2xELElBQUlDLENBQUFBLEdBQUFBLE9BQUFBLEtBQUFBLEVBQU1ILE9BQU9JLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlQO0lBQ0osSUFBSTtRQUNGQSxNQUFNLElBQUlRLElBQUlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlMLE9BQU9GLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSTtJQUN2RCxFQUFFLE9BQU9NLEdBQUc7UUFDViwyRUFBMkU7UUFDM0Usa0RBQWtEO1FBQ2xELE1BQU0sSUFBSUMsTUFDUCxzQkFBbUJQLE9BQUs7SUFFN0I7SUFFQSx1RUFBdUU7SUFDdkUsSUFBSVEsSUFBb0IsRUFBb0I7UUFDMUMsT0FBTztJQUNUO0lBRUEscURBQXFEO0lBQ3JELElBQUliLGNBQWNDLE1BQU07UUFDdEIsT0FBTztJQUNUO0lBRUEsT0FBT0E7QUFDVDtBQUVBLHdCQUF3QixLQUl2QjtJQUp1QixNQUN0QmdCLGNBQWMs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LEdBQ25DLHFCQUFDQyxRQUFBQTtZQUVDQyxLQUFJO1lBQ0p6TCxNQUFPLEtBQUVBLE9BQU9vTDtZQUNoQixhQUFhO1lBQ2JNLFlBQVc7V0FKTkg7QUFVWDs7TUE3QlN0QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxFZHVhcmRvXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcYXBwLXJvdXRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwge1xuICB1c2UsXG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlQ2FsbGJhY2ssXG4gIHN0YXJ0VHJhbnNpdGlvbixcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VEZWZlcnJlZFZhbHVlLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIEFwcFJvdXRlckNvbnRleHQsXG4gIExheW91dFJvdXRlckNvbnRleHQsXG4gIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGUsXG4gIEFwcFJvdXRlckluc3RhbmNlLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7XG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgQUNUSU9OX05BVklHQVRFLFxuICBBQ1RJT05fUFJFRkVUQ0gsXG4gIEFDVElPTl9SRUZSRVNILFxuICBBQ1RJT05fUkVTVE9SRSxcbiAgQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgUHJlZmV0Y2hLaW5kLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBSb3V0ZXJTdGF0ZSxcbiAgUmVkdWNlckFjdGlvbnMsXG4gIFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gIFJvdXRlck5hdmlnYXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aG5hbWVDb250ZXh0LFxuICBQYXRoUGFyYW1zQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZVVud3JhcFN0YXRlIH0gZnJvbSAnLi91c2UtcmVkdWNlcidcbmltcG9ydCB7IEVycm9yQm91bmRhcnksIHR5cGUgRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHsgaXNCb3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBBcHBSb3V0ZXJBbm5vdW5jZXIgfSBmcm9tICcuL2FwcC1yb3V0ZXItYW5ub3VuY2VyJ1xuaW1wb3J0IHsgUmVkaXJlY3RCb3VuZGFyeSB9IGZyb20gJy4vcmVkaXJlY3QtYm91bmRhcnknXG5pbXBvcnQgeyBmaW5kSGVhZEluQ2FjaGUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IGdldFNlbGVjdGVkUGFyYW1zIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IHVzZU5hdkZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi9uYXYtZmFpbHVyZS1oYW5kbGVyJ1xuaW1wb3J0IHsgdXNlU2VydmVyQWN0aW9uRGlzcGF0Y2hlciB9IGZyb20gJy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVyQWN0aW9uUXVldWUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci9hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBwcmVmZXRjaCBhcyBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUgfSBmcm9tICcuLi9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUvcHJlZmV0Y2gnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IsIGdldFVSTEZyb21SZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdCdcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcblxuY29uc3QgZ2xvYmFsTXV0YWJsZToge1xuICBwZW5kaW5nTXBhUGF0aD86IHN0cmluZ1xufSA9IHt9XG5cbmZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsOiBVUkwpIHtcbiAgcmV0dXJuIHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpbmsgaHJlZiwgY29uc3RydWN0cyB0aGUgVVJMIHRoYXQgc2hvdWxkIGJlIHByZWZldGNoZWQuIFJldHVybnMgbnVsbFxuICogaW4gY2FzZXMgd2hlcmUgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkLCBsaWtlIGV4dGVybmFsIFVSTHMsIG9yXG4gKiBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gKiBAcGFyYW0gaHJlZiBUaGUgaHJlZiBwYXNzZWQgdG8gPExpbms+LCByb3V0ZXIucHJlZmV0Y2goKSwgb3Igc2ltaWxhclxuICogQHJldHVybnMgQSBVUkwgb2JqZWN0IHRvIHByZWZldGNoLCBvciBudWxsIGlmIHByZWZldGNoaW5nIHNob3VsZCBiZSBkaXNhYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIC8vIERvbid0IHByZWZldGNoIGZvciBib3RzIGFzIHRoZXkgZG9uJ3QgbmF2aWdhdGUuXG4gIGlmIChpc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCB0byB0aHJvdyBvciBjYW4gd2UganVzdCBjb25zb2xlLmVycm9yIGluc3RlYWQ/IERvZXNcbiAgICAvLyBhbnlvbmUgcmVseSBvbiB0aGlzIHRocm93aW5nPyAoU2VlbXMgdW5saWtlbHkuKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICB9XG5cbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZHVyaW5nIGRldmVsb3BtZW50IChpbXByb3ZlcyBjb21waWxhdGlvbiBwZXJmb3JtYW5jZSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHVybHMgY2FuJ3QgYmUgcHJlZmV0Y2hlZCBpbiB0aGUgc2FtZSB3YXkuXG4gIGlmIChpc0V4dGVybmFsVVJMKHVybCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBIaXN0b3J5VXBkYXRlcih7XG4gIGFwcFJvdXRlclN0YXRlLFxufToge1xuICBhcHBSb3V0ZXJTdGF0ZTogQXBwUm91dGVyU3RhdGVcbn0pIHtcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgICAgLy8gY2xlYXIgcGVuZGluZyBVUkwgYXMgbmF2aWdhdGlvbiBpcyBubyBsb25nZXJcbiAgICAgIC8vIGluIGZsaWdodFxuICAgICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmVlLCBwdXNoUmVmLCBjYW5vbmljYWxVcmwgfSA9IGFwcFJvdXRlclN0YXRlXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0ge1xuICAgICAgLi4uKHB1c2hSZWYucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPyB3aW5kb3cuaGlzdG9yeS5zdGF0ZSA6IHt9KSxcbiAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAvLyBfX04gaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgIF9fTkE6IHRydWUsXG4gICAgICBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFOiB0cmVlLFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoICYmXG4gICAgICAvLyBTa2lwIHB1c2hpbmcgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5IGlmIHRoZSBjYW5vbmljYWxVcmwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdXJsLlxuICAgICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyIGJlaGF2aW9yIGZvciBub3JtYWwgbmF2aWdhdGlvbi5cbiAgICAgIGNyZWF0ZUhyZWZGcm9tVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpKSAhPT0gY2Fub25pY2FsVXJsXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgbXV0YXRlcyBSZWFjdCBzdGF0ZSwgcHVzaFJlZiBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgYWRkaXRpb25hbCBwdXNoL3JlcGxhY2UgY2FsbHMgZG8gbm90IHRyaWdnZXIgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5LlxuICAgICAgcHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlXSlcbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKCk6IENhY2hlTm9kZSB7XG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBudWxsLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgbG9hZGluZzogbnVsbCxcbiAgfVxufVxuXG4vKipcbiAqIFNlcnZlciByZXNwb25zZSB0aGF0IG9ubHkgcGF0Y2hlcyB0aGUgY2FjaGUgYW5kIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHVzZUNoYW5nZUJ5U2VydmVyUmVzcG9uc2UoXG4gIGRpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxSZWR1Y2VyQWN0aW9ucz5cbik6IFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2Uge1xuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKHsgcHJldmlvdXNUcmVlLCBzZXJ2ZXJSZXNwb25zZSB9KSA9PiB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgc2VydmVyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgW2Rpc3BhdGNoXVxuICApXG59XG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKGRpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxSZWR1Y2VyQWN0aW9ucz4pOiBSb3V0ZXJOYXZpZ2F0ZSB7XG4gIHJldHVybiB1c2VDYWxsYmFjayhcbiAgICAoaHJlZiwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYWRkQmFzZVBhdGgoaHJlZiksIGxvY2F0aW9uLmhyZWYpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICAgIHdpbmRvdy5uZXh0Ll9fcGVuZGluZ1VybCA9IHVybFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBBQ1RJT05fTkFWSUdBVEUsXG4gICAgICAgIHVybCxcbiAgICAgICAgaXNFeHRlcm5hbFVybDogaXNFeHRlcm5hbFVSTCh1cmwpLFxuICAgICAgICBsb2NhdGlvblNlYXJjaDogbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBzaG91bGRTY3JvbGw6IHNob3VsZFNjcm9sbCA/PyB0cnVlLFxuICAgICAgICBuYXZpZ2F0ZVR5cGUsXG4gICAgICAgIGFsbG93QWxpYXNpbmc6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG4gICAgW2Rpc3BhdGNoXVxuICApXG59XG5cbmZ1bmN0aW9uIGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhOiBhbnkpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkgZGF0YSA9IHt9XG4gIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gIGNvbnN0IF9fTkEgPSBjdXJyZW50U3RhdGU/Ll9fTkFcbiAgaWYgKF9fTkEpIHtcbiAgICBkYXRhLl9fTkEgPSBfX05BXG4gIH1cbiAgY29uc3QgX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSA9XG4gICAgY3VycmVudFN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIGlmIChfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFKSB7XG4gICAgZGF0YS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID0gX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gSGVhZCh7XG4gIGhlYWRDYWNoZU5vZGUsXG59OiB7XG4gIGhlYWRDYWNoZU5vZGU6IENhY2hlTm9kZSB8IG51bGxcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoSGVhZGAsIGl0J3MgdGhlIHN0YXRpY2FsbHkgcHJlZmV0Y2hlZCBkYXRhLlxuICAvLyBXZSBzaG91bGQgdXNlIHRoYXQgb24gaW5pdGlhbCByZW5kZXIgaW5zdGVhZCBvZiBgaGVhZGAuIFRoZW4gd2UnbGwgc3dpdGNoXG4gIC8vIHRvIGBoZWFkYCB3aGVuIHRoZSBkeW5hbWljIHJlc3BvbnNlIHN0cmVhbXMgaW4uXG4gIGNvbnN0IGhlYWQgPSBoZWFkQ2FjaGVOb2RlICE9PSBudWxsID8gaGVhZENhY2hlTm9kZS5oZWFkIDogbnVsbFxuICBjb25zdCBwcmVmZXRjaEhlYWQgPVxuICAgIGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCA6IG51bGxcblxuICAvLyBJZiBubyBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgYGhlYWRgLlxuICBjb25zdCByZXNvbHZlZFByZWZldGNoUnNjID0gcHJlZmV0Y2hIZWFkICE9PSBudWxsID8gcHJlZmV0Y2hIZWFkIDogaGVhZFxuXG4gIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAvLyBmaW5hbCB2YWx1ZXMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgcmV0dXJuZWQgb24gaW5pdGlhbCByZW5kZXIsIHRoZW4gaXRcbiAgLy8gcmUtcmVuZGVycyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgLy9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIGB1c2VEZWZlcnJlZFZhbHVlYCBpcyBvbmx5XG4gIC8vIGF2YWlsYWJsZSBpbiB0aGUgZXhwZXJpbWVudGFsIGJ1aWxkcy4gV2hlbiBpdHMgZGlzYWJsZWQsIGl0IHdpbGwgYWx3YXlzXG4gIC8vIHJldHVybiBgaGVhZGAuXG4gIHJldHVybiB1c2VEZWZlcnJlZFZhbHVlKGhlYWQsIHJlc29sdmVkUHJlZmV0Y2hSc2MpXG59XG5cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gUm91dGVyKHtcbiAgYWN0aW9uUXVldWUsXG4gIGFzc2V0UHJlZml4LFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xufSkge1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoYWN0aW9uUXVldWUpXG4gIGNvbnN0IHsgY2Fub25pY2FsVXJsIH0gPSB1c2VVbndyYXBTdGF0ZShzdGF0ZSlcbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICBjb25zdCB7IHNlYXJjaFBhcmFtcywgcGF0aG5hbWUgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBoYXNCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgID8gcmVtb3ZlQmFzZVBhdGgodXJsLnBhdGhuYW1lKVxuICAgICAgICA6IHVybC5wYXRobmFtZSxcbiAgICB9XG4gIH0sIFtjYW5vbmljYWxVcmxdKVxuXG4gIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSB1c2VDaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGRpc3BhdGNoKVxuICBjb25zdCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKGRpc3BhdGNoKVxuICB1c2VTZXJ2ZXJBY3Rpb25EaXNwYXRjaGVyKGRpc3BhdGNoKVxuXG4gIC8qKlxuICAgKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gSXQncyBvbmx5IGNvbmNlcm5lZCB3aXRoIGRpc3BhdGNoaW5nIGFjdGlvbnMgdG8gdGhlIHJlZHVjZXIsIGRvZXMgbm90IGhvbGQgc3RhdGUuXG4gICAqL1xuICBjb25zdCBhcHBSb3V0ZXIgPSB1c2VNZW1vPEFwcFJvdXRlckluc3RhbmNlPigoKSA9PiB7XG4gICAgY29uc3Qgcm91dGVySW5zdGFuY2U6IEFwcFJvdXRlckluc3RhbmNlID0ge1xuICAgICAgYmFjazogKCkgPT4gd2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICAgICAgZm9yd2FyZDogKCkgPT4gd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLFxuICAgICAgcHJlZmV0Y2g6XG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9QUFIgJiYgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgICAgICAgPyAvLyBVbmxpa2UgdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgdGhlIFNlZ21lbnQgQ2FjaGUgZG9lc24ndCBzdG9yZSBpdHNcbiAgICAgICAgICAgIC8vIGRhdGEgaW4gdGhlIHJvdXRlciByZWR1Y2VyIHN0YXRlOyBpdCB3cml0ZXMgaW50byBhIGdsb2JhbCBtdXRhYmxlXG4gICAgICAgICAgICAvLyBjYWNoZS4gU28gd2UgZG9uJ3QgbmVlZCB0byBkaXNwYXRjaCBhbiBhY3Rpb24uXG4gICAgICAgICAgICAoaHJlZikgPT4gcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlKGhyZWYsIGFjdGlvblF1ZXVlLnN0YXRlLm5leHRVcmwpXG4gICAgICAgICAgOiAoaHJlZiwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAvLyBVc2UgdGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgY29uc3QgdXJsID0gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZilcbiAgICAgICAgICAgICAgaWYgKHVybCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEFDVElPTl9QUkVGRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBvcHRpb25zPy5raW5kID8/IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgcmVwbGFjZTogKGhyZWYsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIG5hdmlnYXRlKGhyZWYsICdyZXBsYWNlJywgb3B0aW9ucy5zY3JvbGwgPz8gdHJ1ZSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBwdXNoOiAoaHJlZiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3B1c2gnLCBvcHRpb25zLnNjcm9sbCA/PyB0cnVlKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlZnJlc2g6ICgpID0+IHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVGUkVTSCxcbiAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGhtclJlZnJlc2g6ICgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2htclJlZnJlc2ggY2FuIG9ubHkgYmUgdXNlZCBpbiBkZXZlbG9wbWVudCBtb2RlLiBQbGVhc2UgdXNlIHJlZnJlc2ggaW5zdGVhZC4nXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHR5cGU6IEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cblxuICAgIHJldHVybiByb3V0ZXJJbnN0YW5jZVxuICB9LCBbYWN0aW9uUXVldWUsIGRpc3BhdGNoLCBuYXZpZ2F0ZV0pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBFeGlzdHMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gRG9uJ3QgdXNlIGluIGFwcGxpY2F0aW9uIGNvZGUuXG4gICAgaWYgKHdpbmRvdy5uZXh0KSB7XG4gICAgICB3aW5kb3cubmV4dC5yb3V0ZXIgPSBhcHBSb3V0ZXJcbiAgICB9XG4gIH0sIFthcHBSb3V0ZXJdKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3QgeyBjYWNoZSwgcHJlZmV0Y2hDYWNoZSwgdHJlZSB9ID0gdXNlVW53cmFwU3RhdGUoc3RhdGUpXG5cbiAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBBZGQgYHdpbmRvdy5uZGAgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyBmb3IgZGVidWdnaW5nXG4gICAgICB3aW5kb3cubmQgPSB7XG4gICAgICAgIHJvdXRlcjogYXBwUm91dGVyLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgdHJlZSxcbiAgICAgIH1cbiAgICB9LCBbYXBwUm91dGVyLCBjYWNoZSwgcHJlZmV0Y2hDYWNoZSwgdHJlZV0pXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBhcHAgaXMgcmVzdG9yZWQgZnJvbSBiZmNhY2hlLCBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAvLyBwdXNoUmVmLm1wYU5hdmlnYXRpb24gaXMgdHJ1ZSwgd2hpY2ggd291bGQgbWVhbiB0aGF0IGFueSByZS1yZW5kZXIgb2YgdGhpcyBjb21wb25lbnRcbiAgICAvLyB3b3VsZCB0cmlnZ2VyIHRoZSBtcGEgbmF2aWdhdGlvbiBsb2dpYyBhZ2FpbiBmcm9tIHRoZSBsaW5lcyBiZWxvdy5cbiAgICAvLyBUaGlzIHdpbGwgcmVzdG9yZSB0aGUgcm91dGVyIHRvIHRoZSBpbml0aWFsIHN0YXRlIGluIHRoZSBldmVudCB0aGF0IHRoZSBhcHAgaXMgcmVzdG9yZWQgZnJvbSBiZmNhY2hlLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVBhZ2VTaG93KGV2ZW50OiBQYWdlVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgICFldmVudC5wZXJzaXN0ZWQgfHxcbiAgICAgICAgIXdpbmRvdy5oaXN0b3J5LnN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHRoZSBwZW5kaW5nTXBhUGF0aCB2YWx1ZSBzbyB0aGF0IGEgc3Vic2VxdWVudCBNUEEgbmF2aWdhdGlvbiB0byB0aGUgc2FtZSBVUkwgY2FuIGJlIHRyaWdnZXJlZC5cbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgaWYgdGhlIGJyb3dzZXIgcmVzdG9yZWQgZnJvbSBiZmNhY2hlLCB0aGUgcGVuZGluZ01wYVBhdGggd291bGQgc3RpbGwgYmUgc2V0IHRvIHRoZSB2YWx1ZVxuICAgICAgLy8gb2YgdGhlIGxhc3QgTVBBIG5hdmlnYXRpb24uXG4gICAgICBnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoID0gdW5kZWZpbmVkXG5cbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgIHVybDogbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksXG4gICAgICAgIHRyZWU6IHdpbmRvdy5oaXN0b3J5LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGhhbmRsZVBhZ2VTaG93KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGhhbmRsZVBhZ2VTaG93KVxuICAgIH1cbiAgfSwgW2Rpc3BhdGNoXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEVuc3VyZSB0aGF0IGFueSByZWRpcmVjdCBlcnJvcnMgdGhhdCBidWJibGUgdXAgb3V0c2lkZSBvZiB0aGUgUmVkaXJlY3RCb3VuZGFyeVxuICAgIC8vIGFyZSBjYXVnaHQgYW5kIGhhbmRsZWQgYnkgdGhlIHJvdXRlci5cbiAgICBmdW5jdGlvbiBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdChcbiAgICAgIGV2ZW50OiBFcnJvckV2ZW50IHwgUHJvbWlzZVJlamVjdGlvbkV2ZW50XG4gICAgKSB7XG4gICAgICBjb25zdCBlcnJvciA9ICdyZWFzb24nIGluIGV2ZW50ID8gZXZlbnQucmVhc29uIDogZXZlbnQuZXJyb3JcbiAgICAgIGlmIChpc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3IpXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VHlwZSA9IGdldFJlZGlyZWN0VHlwZUZyb21FcnJvcihlcnJvcilcbiAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gUmVkaXJlY3RUeXBlLnB1c2gpIHtcbiAgICAgICAgICBhcHBSb3V0ZXIucHVzaCh1cmwsIHt9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcFJvdXRlci5yZXBsYWNlKHVybCwge30pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlcl0pXG5cbiAgLy8gV2hlbiBtcGFOYXZpZ2F0aW9uIGZsYWcgaXMgc2V0IGRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBuZXcgdXJsLlxuICAvLyBJbmZpbml0ZWx5IHN1c3BlbmQgYmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB3YW50IHRvIHJlcmVuZGVyIGFueSBjaGlsZFxuICAvLyBjb21wb25lbnRzIHdpdGggdGhlIG5ldyBVUkwgYW5kIGFueSBlbnRhbmdsZWQgc3RhdGUgdXBkYXRlcyBzaG91bGRuJ3RcbiAgLy8gY29tbWl0IGVpdGhlciAoZWc6IHVzZVRyYW5zaXRpb24gaXNQZW5kaW5nIHNob3VsZCBzdGF5IHRydWUgdW50aWwgdGhlIHBhZ2VcbiAgLy8gdW5sb2FkcykuXG4gIC8vXG4gIC8vIFRoaXMgaXMgYSBzaWRlIGVmZmVjdCBpbiByZW5kZXIuIERvbid0IHRyeSB0aGlzIGF0IGhvbWUsIGtpZHMuIEl0J3NcbiAgLy8gcHJvYmFibHkgc2FmZSBiZWNhdXNlIHdlIGtub3cgdGhpcyBpcyBhIHNpbmdsZXRvbiBjb21wb25lbnQgYW5kIGl0J3MgbmV2ZXJcbiAgLy8gaW4gPE9mZnNjcmVlbj4uIEF0IGxlYXN0IEkgaG9wZSBzby4gKEl0IHdpbGwgcnVuIHR3aWNlIGluIGRldiBzdHJpY3QgbW9kZSxcbiAgLy8gYnV0IHRoYXQncy4uLiBmaW5lPylcbiAgY29uc3QgeyBwdXNoUmVmIH0gPSB1c2VVbndyYXBTdGF0ZShzdGF0ZSlcbiAgaWYgKHB1c2hSZWYubXBhTmF2aWdhdGlvbikge1xuICAgIC8vIGlmIHRoZXJlJ3MgYSByZS1yZW5kZXIsIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbm90aGVyIHJlZGlyZWN0IGlmIG9uZSBpcyBhbHJlYWR5IGluIGZsaWdodCB0byB0aGUgc2FtZSBVUkxcbiAgICBpZiAoZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCAhPT0gY2Fub25pY2FsVXJsKSB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvblxuICAgICAgaWYgKHB1c2hSZWYucGVuZGluZ1B1c2gpIHtcbiAgICAgICAgbG9jYXRpb24uYXNzaWduKGNhbm9uaWNhbFVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoY2Fub25pY2FsVXJsKVxuICAgICAgfVxuXG4gICAgICBnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoID0gY2Fub25pY2FsVXJsXG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBTaG91bGQgd2UgbGlzdGVuIHRvIG5hdmlnYXRlZXJyb3IgaGVyZSB0byBjYXRjaCBmYWlsZWRcbiAgICAvLyBuYXZpZ2F0aW9ucyBzb21laG93PyBBbmQgc2hvdWxkIHdlIGNhbGwgd2luZG93LnN0b3AoKSBpZiBhIFNQQSBuYXZpZ2F0aW9uXG4gICAgLy8gc2hvdWxkIGludGVycnVwdCBhbiBNUEEgb25lP1xuICAgIHVzZSh1bnJlc29sdmVkVGhlbmFibGUpXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsUHVzaFN0YXRlID0gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlLmJpbmQod2luZG93Lmhpc3RvcnkpXG4gICAgY29uc3Qgb3JpZ2luYWxSZXBsYWNlU3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUuYmluZChcbiAgICAgIHdpbmRvdy5oaXN0b3J5XG4gICAgKVxuXG4gICAgLy8gRW5zdXJlIHRoZSBjYW5vbmljYWwgVVJMIGluIHRoZSBOZXh0LmpzIFJvdXRlciBpcyB1cGRhdGVkIHdoZW4gdGhlIFVSTCBpcyBjaGFuZ2VkIHNvIHRoYXQgYHVzZVBhdGhuYW1lYCBhbmQgYHVzZVNlYXJjaFBhcmFtc2AgaG9sZCB0aGUgcHVzaGVkIHZhbHVlcy5cbiAgICBjb25zdCBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UgPSAoXG4gICAgICB1cmw6IHN0cmluZyB8IFVSTCB8IG51bGwgfCB1bmRlZmluZWRcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgY29uc3QgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgfCB1bmRlZmluZWQgPVxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgdXJsOiBuZXcgVVJMKHVybCA/PyBocmVmLCBocmVmKSxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaCBwdXNoU3RhdGUgdG8gZW5zdXJlIGV4dGVybmFsIGNoYW5nZXMgdG8gdGhlIGhpc3RvcnkgYXJlIHJlZmxlY3RlZCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIuXG4gICAgICogRW5zdXJlcyBOZXh0LmpzIGludGVybmFsIGhpc3Rvcnkgc3RhdGUgaXMgY29waWVkIHRvIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBFbnN1cmVzIHVzZVBhdGhuYW1lIGFuZCB1c2VTZWFyY2hQYXJhbXMgaG9sZCB0aGUgbmV3bHkgcHJvdmlkZWQgdXJsLlxuICAgICAqL1xuICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIHB1c2hTdGF0ZShcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIF91bnVzZWQ6IHN0cmluZyxcbiAgICAgIHVybD86IHN0cmluZyB8IFVSTCB8IG51bGxcbiAgICApOiB2b2lkIHtcbiAgICAgIC8vIEF2b2lkIGEgbG9vcCB3aGVuIE5leHQuanMgaW50ZXJuYWxzIHRyaWdnZXIgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgaWYgKGRhdGE/Ll9fTkEgfHwgZGF0YT8uX04pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHVzaFN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhKVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSh1cmwpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbFB1c2hTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2ggcmVwbGFjZVN0YXRlIHRvIGVuc3VyZSBleHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBoaXN0b3J5IGFyZSByZWZsZWN0ZWQgaW4gdGhlIE5leHQuanMgUm91dGVyLlxuICAgICAqIEVuc3VyZXMgTmV4dC5qcyBpbnRlcm5hbCBoaXN0b3J5IHN0YXRlIGlzIGNvcGllZCB0byB0aGUgbmV3IGhpc3RvcnkgZW50cnkuXG4gICAgICogRW5zdXJlcyB1c2VQYXRobmFtZSBhbmQgdXNlU2VhcmNoUGFyYW1zIGhvbGQgdGhlIG5ld2x5IHByb3ZpZGVkIHVybC5cbiAgICAgKi9cbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUoXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBfdW51c2VkOiBzdHJpbmcsXG4gICAgICB1cmw/OiBzdHJpbmcgfCBVUkwgfCBudWxsXG4gICAgKTogdm9pZCB7XG4gICAgICAvLyBBdm9pZCBhIGxvb3Agd2hlbiBOZXh0LmpzIGludGVybmFscyB0cmlnZ2VyIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcbiAgICAgIGlmIChkYXRhPy5fX05BIHx8IGRhdGE/Ll9OKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlcGxhY2VTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgICB9XG4gICAgICBkYXRhID0gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGEpXG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlKHVybClcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbFJlcGxhY2VTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBvcHN0YXRlIGV2ZW50LCB0aGlzIGlzIHVzZWQgdG8gaGFuZGxlIGJhY2svZm9yd2FyZCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICAgKiBUaGF0IGNhc2UgY2FuIGhhcHBlbiB3aGVuIHRoZSBvbGQgcm91dGVyIGluamVjdGVkIHRoZSBoaXN0b3J5IGVudHJ5LlxuICAgICAqL1xuICAgIGNvbnN0IG9uUG9wU3RhdGUgPSAoZXZlbnQ6IFBvcFN0YXRlRXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQuc3RhdGUpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIGhpc3RvcnkgZW50cnkgd2FzIHB1c2hlZCBieSB0aGUgYHBhZ2VzYCByb3V0ZXIuXG4gICAgICBpZiAoIWV2ZW50LnN0YXRlLl9fTkEpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPLUFQUDogSWRlYWxseSB0aGUgYmFjayBidXR0b24gc2hvdWxkIG5vdCB1c2Ugc3RhcnRUcmFuc2l0aW9uIGFzIGl0IHNob3VsZCBhcHBseSB0aGUgdXBkYXRlcyBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBXaXRob3V0IHN0YXJ0VHJhbnNpdGlvbiB3b3JrcyBpZiB0aGUgY2FjaGUgaXMgdGhlcmUgZm9yIHRoaXMgcGF0aFxuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICAgIHVybDogbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksXG4gICAgICAgICAgdHJlZTogZXZlbnQuc3RhdGUuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgcG9wc3RhdGUgZXZlbnQgdG8gY2FsbCBvblBvcHN0YXRlLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9IG9yaWdpbmFsUHVzaFN0YXRlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBvcmlnaW5hbFJlcGxhY2VTdGF0ZVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSlcbiAgICB9XG4gIH0sIFtkaXNwYXRjaF0pXG5cbiAgY29uc3QgeyBjYWNoZSwgdHJlZSwgbmV4dFVybCwgZm9jdXNBbmRTY3JvbGxSZWYgfSA9IHVzZVVud3JhcFN0YXRlKHN0YXRlKVxuXG4gIGNvbnN0IG1hdGNoaW5nSGVhZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBmaW5kSGVhZEluQ2FjaGUoY2FjaGUsIHRyZWVbMV0pXG4gIH0sIFtjYWNoZSwgdHJlZV0pXG5cbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhQYXJhbXMgZm9yIHVzZVBhcmFtcy5cbiAgY29uc3QgcGF0aFBhcmFtcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBnZXRTZWxlY3RlZFBhcmFtcyh0cmVlKVxuICB9LCBbdHJlZV0pXG5cbiAgY29uc3QgbGF5b3V0Um91dGVyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZE5vZGVzOiBjYWNoZS5wYXJhbGxlbFJvdXRlcyxcbiAgICAgIHRyZWUsXG4gICAgICAvLyBSb290IG5vZGUgYWx3YXlzIGhhcyBgdXJsYFxuICAgICAgLy8gUHJvdmlkZWQgaW4gQXBwVHJlZUNvbnRleHQgdG8gZW5zdXJlIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBsYXlvdXQtcm91dGVyXG4gICAgICB1cmw6IGNhbm9uaWNhbFVybCxcbiAgICAgIGxvYWRpbmc6IGNhY2hlLmxvYWRpbmcsXG4gICAgfVxuICB9LCBbY2FjaGUucGFyYWxsZWxSb3V0ZXMsIHRyZWUsIGNhbm9uaWNhbFVybCwgY2FjaGUubG9hZGluZ10pXG5cbiAgY29uc3QgZ2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlLFxuICAgICAgdHJlZSxcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgbmV4dFVybCxcbiAgICB9XG4gIH0sIFtjaGFuZ2VCeVNlcnZlclJlc3BvbnNlLCB0cmVlLCBmb2N1c0FuZFNjcm9sbFJlZiwgbmV4dFVybF0pXG5cbiAgbGV0IGhlYWRcbiAgaWYgKG1hdGNoaW5nSGVhZCAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBoZWFkIGlzIHdyYXBwZWQgaW4gYW4gZXh0cmEgY29tcG9uZW50IHNvIHdlIGNhbiB1c2VcbiAgICAvLyBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gc3dhcCBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZCBmaW5hbCB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSBoZWFkLiAoVGhpcyBpcyB3aGF0IExheW91dFJvdXRlciBkb2VzIGZvciBzZWdtZW50IGRhdGEsIHRvby4pXG4gICAgLy9cbiAgICAvLyBUaGUgYGtleWAgaXMgdXNlZCB0byByZW1vdW50IHRoZSBjb21wb25lbnQgd2hlbmV2ZXIgdGhlIGhlYWQgbW92ZXMgdG9cbiAgICAvLyBhIGRpZmZlcmVudCBzZWdtZW50LlxuICAgIGNvbnN0IFtoZWFkQ2FjaGVOb2RlLCBoZWFkS2V5XSA9IG1hdGNoaW5nSGVhZFxuICAgIGhlYWQgPSA8SGVhZCBrZXk9e2hlYWRLZXl9IGhlYWRDYWNoZU5vZGU9e2hlYWRDYWNoZU5vZGV9IC8+XG4gIH0gZWxzZSB7XG4gICAgaGVhZCA9IG51bGxcbiAgfVxuXG4gIGxldCBjb250ZW50ID0gKFxuICAgIDxSZWRpcmVjdEJvdW5kYXJ5PlxuICAgICAge2hlYWR9XG4gICAgICB7Y2FjaGUucnNjfVxuICAgICAgPEFwcFJvdXRlckFubm91bmNlciB0cmVlPXt0cmVlfSAvPlxuICAgIDwvUmVkaXJlY3RCb3VuZGFyeT5cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vZGV2LXJvb3QtaHR0cC1hY2Nlc3MtZmFsbGJhY2stYm91bmRhcnknKVxuICAgICAgY29udGVudCA9IChcbiAgICAgICAgPERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgPC9EZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IEhvdFJlbG9hZGVyOiB0eXBlb2YgaW1wb3J0KCcuL3JlYWN0LWRldi1vdmVybGF5L2FwcC9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdCA9XG4gICAgICByZXF1aXJlKCcuL3JlYWN0LWRldi1vdmVybGF5L2FwcC9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdFxuXG4gICAgY29udGVudCA9IDxIb3RSZWxvYWRlciBhc3NldFByZWZpeD17YXNzZXRQcmVmaXh9Pntjb250ZW50fTwvSG90UmVsb2FkZXI+XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGlzdG9yeVVwZGF0ZXIgYXBwUm91dGVyU3RhdGU9e3VzZVVud3JhcFN0YXRlKHN0YXRlKX0gLz5cbiAgICAgIDxSdW50aW1lU3R5bGVzIC8+XG4gICAgICA8UGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhdGhQYXJhbXN9PlxuICAgICAgICA8UGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwYXRobmFtZX0+XG4gICAgICAgICAgPFNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3NlYXJjaFBhcmFtc30+XG4gICAgICAgICAgICA8R2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgICAgICB2YWx1ZT17Z2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2FwcFJvdXRlcn0+XG4gICAgICAgICAgICAgICAgPExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2xheW91dFJvdXRlckNvbnRleHR9PlxuICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAgPC9MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICA8L0FwcFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L0dsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgPC9TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1BhdGhuYW1lQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvUGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgPC8+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwUm91dGVyKHtcbiAgYWN0aW9uUXVldWUsXG4gIGdsb2JhbEVycm9yQ29tcG9uZW50QW5kU3R5bGVzOiBbZ2xvYmFsRXJyb3JDb21wb25lbnQsIGdsb2JhbEVycm9yU3R5bGVzXSxcbiAgYXNzZXRQcmVmaXgsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBnbG9iYWxFcnJvckNvbXBvbmVudEFuZFN0eWxlczogW0Vycm9yQ29tcG9uZW50LCBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWRdXG4gIGFzc2V0UHJlZml4OiBzdHJpbmdcbn0pIHtcbiAgdXNlTmF2RmFpbHVyZUhhbmRsZXIoKVxuXG4gIHJldHVybiAoXG4gICAgPEVycm9yQm91bmRhcnlcbiAgICAgIGVycm9yQ29tcG9uZW50PXtnbG9iYWxFcnJvckNvbXBvbmVudH1cbiAgICAgIGVycm9yU3R5bGVzPXtnbG9iYWxFcnJvclN0eWxlc31cbiAgICA+XG4gICAgICA8Um91dGVyIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX0gYXNzZXRQcmVmaXg9e2Fzc2V0UHJlZml4fSAvPlxuICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuXG5jb25zdCBydW50aW1lU3R5bGVzID0gbmV3IFNldDxzdHJpbmc+KClcbmxldCBydW50aW1lU3R5bGVDaGFuZ2VkID0gbmV3IFNldDwoKSA9PiB2b2lkPigpXG5cbmdsb2JhbFRoaXMuX05fRV9TVFlMRV9MT0FEID0gZnVuY3Rpb24gKGhyZWY6IHN0cmluZykge1xuICBsZXQgbGVuID0gcnVudGltZVN0eWxlcy5zaXplXG4gIHJ1bnRpbWVTdHlsZXMuYWRkKGhyZWYpXG4gIGlmIChydW50aW1lU3R5bGVzLnNpemUgIT09IGxlbikge1xuICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIH1cbiAgLy8gVE9ETyBmaWd1cmUgb3V0IGhvdyB0byBnZXQgYSBwcm9taXNlIGhlcmVcbiAgLy8gQnV0IG1heWJlIGl0J3Mgbm90IG5lY2Vzc2FyeSBhcyByZWFjdCB3b3VsZCBibG9jayByZW5kZXJpbmcgdW50aWwgaXQncyBsb2FkZWRcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG59XG5cbmZ1bmN0aW9uIFJ1bnRpbWVTdHlsZXMoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IFJlYWN0LnVzZVN0YXRlKDApXG4gIGNvbnN0IHJlbmRlcmVkU3R5bGVzU2l6ZSA9IHJ1bnRpbWVTdHlsZXMuc2l6ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNoYW5nZWQgPSAoKSA9PiBmb3JjZVVwZGF0ZSgoYykgPT4gYyArIDEpXG4gICAgcnVudGltZVN0eWxlQ2hhbmdlZC5hZGQoY2hhbmdlZClcbiAgICBpZiAocmVuZGVyZWRTdHlsZXNTaXplICE9PSBydW50aW1lU3R5bGVzLnNpemUpIHtcbiAgICAgIGNoYW5nZWQoKVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcnVudGltZVN0eWxlQ2hhbmdlZC5kZWxldGUoY2hhbmdlZClcbiAgICB9XG4gIH0sIFtyZW5kZXJlZFN0eWxlc1NpemUsIGZvcmNlVXBkYXRlXSlcblxuICBjb25zdCBkcGxJZCA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgID8gYD9kcGw9JHtwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUR9YFxuICAgIDogJydcbiAgcmV0dXJuIFsuLi5ydW50aW1lU3R5bGVzXS5tYXAoKGhyZWYsIGkpID0+IChcbiAgICA8bGlua1xuICAgICAga2V5PXtpfVxuICAgICAgcmVsPVwic3R5bGVzaGVldFwiXG4gICAgICBocmVmPXtgJHtocmVmfSR7ZHBsSWR9YH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHByZWNlZGVuY2U9XCJuZXh0XCJcbiAgICAgIC8vIFRPRE8gZmlndXJlIG91dCBjcm9zc09yaWdpbiBhbmQgbm9uY2VcbiAgICAgIC8vIGNyb3NzT3JpZ2luPXtUT0RPfVxuICAgICAgLy8gbm9uY2U9e1RPRE99XG4gICAgLz5cbiAgKSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImNyZWF0ZVByZWZldGNoVVJMIiwiQXBwUm91dGVyIiwiZ2xvYmFsTXV0YWJsZSIsImlzRXh0ZXJuYWxVUkwiLCJ1cmwiLCJvcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlVSTCIsImFkZEJhc2VQYXRoIiwiXyIsIkVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiSGlzdG9yeVVwZGF0ZXIiLCJhcHBSb3V0ZXJTdGF0ZSIsInVzZUluc2VydGlvbkVmZmVjdCIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJuZXh0IiwiX19wZW5kaW5nVXJsIiwidW5kZWZpbmVkIiwidHJlZSIsInB1c2hSZWYiLCJjYW5vbmljYWxVcmwiLCJoaXN0b3J5U3RhdGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhpc3RvcnkiLCJzdGF0ZSIsIl9fTkEiLCJfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFIiwicGVuZGluZ1B1c2giLCJjcmVhdGVIcmVmRnJvbVVybCIsInB1c2hTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJsb2FkaW5nIiwidXNlQ2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsImRpc3BhdGNoIiwidXNlQ2FsbGJhY2siLCJwcmV2aW91c1RyZWUiLCJzZXJ2ZXJSZXNwb25zZSIsInN0YXJ0VHJhbnNpdGlvbiIsInR5cGUiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwidXNlTmF2aWdhdGUiLCJuYXZpZ2F0ZVR5cGUiLCJzaG91bGRTY3JvbGwiLCJBQ1RJT05fTkFWSUdBVEUiLCJpc0V4dGVybmFsVXJsIiwibG9jYXRpb25TZWFyY2giLCJzZWFyY2giLCJhbGxvd0FsaWFzaW5nIiwiY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlIiwiZGF0YSIsImN1cnJlbnRTdGF0ZSIsIkhlYWQiLCJoZWFkQ2FjaGVOb2RlIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJSb3V0ZXIiLCJhY3Rpb25RdWV1ZSIsImFzc2V0UHJlZml4IiwidXNlUmVkdWNlciIsInVzZVVud3JhcFN0YXRlIiwic2VhcmNoUGFyYW1zIiwicGF0aG5hbWUiLCJ1c2VNZW1vIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJuYXZpZ2F0ZSIsInVzZVNlcnZlckFjdGlvbkRpc3BhdGNoZXIiLCJhcHBSb3V0ZXIiLCJyb3V0ZXJJbnN0YW5jZSIsImJhY2siLCJmb3J3YXJkIiwicHJlZmV0Y2giLCJfX05FWFRfUFBSIiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlIiwibmV4dFVybCIsIm9wdGlvbnMiLCJBQ1RJT05fUFJFRkVUQ0giLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsInJlcGxhY2UiLCJzY3JvbGwiLCJwdXNoIiwicmVmcmVzaCIsIkFDVElPTl9SRUZSRVNIIiwiaG1yUmVmcmVzaCIsIkFDVElPTl9ITVJfUkVGUkVTSCIsInVzZUVmZmVjdCIsInJvdXRlciIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsIm5kIiwiaGFuZGxlUGFnZVNob3ciLCJldmVudCIsInBlcnNpc3RlZCIsInBlbmRpbmdNcGFQYXRoIiwiQUNUSU9OX1JFU1RPUkUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0IiwiZXJyb3IiLCJyZWFzb24iLCJpc1JlZGlyZWN0RXJyb3IiLCJwcmV2ZW50RGVmYXVsdCIsImdldFVSTEZyb21SZWRpcmVjdEVycm9yIiwicmVkaXJlY3RUeXBlIiwiZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yIiwiUmVkaXJlY3RUeXBlIiwibXBhTmF2aWdhdGlvbiIsImFzc2lnbiIsInVzZSIsInVucmVzb2x2ZWRUaGVuYWJsZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiYmluZCIsIm9yaWdpbmFsUmVwbGFjZVN0YXRlIiwiYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlIiwiX3VudXNlZCIsIl9OIiwib25Qb3BTdGF0ZSIsInJlbG9hZCIsImZvY3VzQW5kU2Nyb2xsUmVmIiwibWF0Y2hpbmdIZWFkIiwiZmluZEhlYWRJbkNhY2hlIiwicGF0aFBhcmFtcyIsImdldFNlbGVjdGVkUGFyYW1zIiwibGF5b3V0Um91dGVyQ29udGV4dCIsImNoaWxkTm9kZXMiLCJnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiaGVhZEtleSIsImNvbnRlbnQiLCJSZWRpcmVjdEJvdW5kYXJ5IiwiQXBwUm91dGVyQW5ub3VuY2VyIiwiRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IiwicmVxdWlyZSIsIkhvdFJlbG9hZGVyIiwiZGVmYXVsdCIsIlJ1bnRpbWVTdHlsZXMiLCJQYXRoUGFyYW1zQ29udGV4dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJQYXRobmFtZUNvbnRleHQiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiZ2xvYmFsRXJyb3JDb21wb25lbnRBbmRTdHlsZXMiLCJnbG9iYWxFcnJvckNvbXBvbmVudCIsImdsb2JhbEVycm9yU3R5bGVzIiwidXNlTmF2RmFpbHVyZUhhbmRsZXIiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJlcnJvclN0eWxlcyIsInJ1bnRpbWVTdHlsZXMiLCJTZXQiLCJydW50aW1lU3R5bGVDaGFuZ2VkIiwiZ2xvYmFsVGhpcyIsIl9OX0VfU1RZTEVfTE9BRCIsImxlbiIsInNpemUiLCJhZGQiLCJmb3JFYWNoIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZvcmNlVXBkYXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInJlbmRlcmVkU3R5bGVzU2l6ZSIsImNoYW5nZWQiLCJjIiwiZGVsZXRlIiwiZHBsSWQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJtYXAiLCJpIiwibGluayIsInJlbCIsInByZWNlZGVuY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/globals/intercept-console-error.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    originConsoleError: function() {\n        return originConsoleError;\n    },\n    patchConsoleError: function() {\n        return patchConsoleError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ../is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../react-dev-overlay/internal/helpers/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-error-handler.js\");\nconst originConsoleError = window.console.error;\nfunction patchConsoleError() {\n    // Ensure it's only patched once\n    if (typeof window === 'undefined') {\n        return;\n    }\n    window.console.error = function error() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        let maybeError;\n        if (true) {\n            const replayedError = matchReplayedError(...args);\n            if (replayedError) {\n                maybeError = replayedError;\n            } else if ((0, _iserror.default)(args[0])) {\n                maybeError = args[0];\n            } else {\n                // See https://github.com/facebook/react/blob/d50323eb845c5fde0d720cae888bf35dedd05506/packages/react-reconciler/src/ReactFiberErrorLogger.js#L78\n                maybeError = args[1];\n            }\n        } else {}\n        if (!(0, _isnextroutererror.isNextRouterError)(maybeError)) {\n            if (true) {\n                (0, _useerrorhandler.handleClientError)(// but if we pass the error directly, `handleClientError` will ignore it\n                maybeError, args, true);\n            }\n            originConsoleError.apply(window.console, args);\n        }\n    };\n}\nfunction matchReplayedError() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // See\n    // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n    //\n    // Logs replayed from the server look like this:\n    // [\n    //   \"%c%s%c %o\\n\\n%s\\n\\n%s\\n\",\n    //   \"background: #e6e6e6; ...\",\n    //   \" Server \", // can also be e.g. \" Prerender \"\n    //   \"\",\n    //   Error\n    //   \"The above error occurred in the <Page> component.\"\n    //   ...\n    // ]\n    if (args.length > 3 && typeof args[0] === 'string' && args[0].startsWith('%c%s%c ') && typeof args[1] === 'string' && typeof args[2] === 'string' && typeof args[3] === 'string') {\n        const maybeError = args[4];\n        if ((0, _iserror.default)(maybeError)) {\n            return maybeError;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=intercept-console-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZ2xvYmFscy9pbnRlcmNlcHQtY29uc29sZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFJYUEsa0JBQWtCO2VBQWxCQTs7SUFHR0MsaUJBQWlCO2VBQWpCQTs7Ozs4RUFQSTsrQ0FDYzs2Q0FDQTtBQUUzQixNQUFNRCxxQkFBcUJFLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSztBQUcvQyxTQUFTSDtJQUNkLGdDQUFnQztJQUNoQyxJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUNqQztJQUNGO0lBQ0FBLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHLFNBQVNBO1FBQU0saUNBQUdDLE9BQUg7WUFBR0EsSUFBQUEsQ0FBSCx1QkFBYzs7UUFDbEQsSUFBSUM7UUFDSixJQUFJQyxJQUFvQixFQUFtQjtZQUN6QyxNQUFNRyxnQkFBZ0JDLHNCQUFzQk47WUFDNUMsSUFBSUssZUFBZTtnQkFDakJKLGFBQWFJO1lBQ2YsT0FBTyxJQUFJRSxDQUFBQSxHQUFBQSxTQUFBQSxPQUFBQSxFQUFRUCxJQUFJLENBQUMsRUFBRSxHQUFHO2dCQUMzQkMsYUFBYUQsSUFBSSxDQUFDLEVBQUU7WUFDdEIsT0FBTztnQkFDTCxpSkFBaUo7Z0JBQ2pKQyxhQUFhRCxJQUFJLENBQUMsRUFBRTtZQUN0QjtRQUNGLE9BQU8sRUFFTjtRQUVELElBQUksQ0FBQ1EsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQlAsYUFBYTtZQUNsQyxJQUFJQyxJQUFvQixFQUFtQjtnQkFDekNPLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDRSx3RUFDd0U7Z0JBQ3hFUixZQUNBRCxNQUNBO1lBRUo7WUFFQUwsbUJBQW1CZSxLQUFLLENBQUNiLE9BQU9DLE9BQU8sRUFBRUU7UUFDM0M7SUFDRjtBQUNGO0FBRUEsU0FBU007SUFBbUIsaUNBQUdOLE9BQUg7UUFBR0EsSUFBQUEsQ0FBSCx1QkFBa0I7O0lBQzVDLE1BQU07SUFDTix3SkFBd0o7SUFDeEosRUFBRTtJQUNGLGdEQUFnRDtJQUNoRCxJQUFJO0lBQ0osK0JBQStCO0lBQy9CLGdDQUFnQztJQUNoQyxrREFBa0Q7SUFDbEQsUUFBUTtJQUNSLFVBQVU7SUFDVix3REFBd0Q7SUFDeEQsUUFBUTtJQUNSLElBQUk7SUFDSixJQUNFQSxLQUFLVyxNQUFNLEdBQUcsS0FDZCxPQUFPWCxJQUFJLENBQUMsRUFBRSxLQUFLLFlBQ25CQSxJQUFJLENBQUMsRUFBRSxDQUFDWSxVQUFVLENBQUMsY0FDbkIsT0FBT1osSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUNuQixPQUFPQSxJQUFJLENBQUMsRUFBRSxLQUFLLFlBQ25CLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssVUFDbkI7UUFDQSxNQUFNQyxhQUFhRCxJQUFJLENBQUMsRUFBRTtRQUMxQixJQUFJTyxDQUFBQSxHQUFBQSxTQUFBQSxPQUFBQSxFQUFRTixhQUFhO1lBQ3ZCLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcZ2xvYmFsc1xcaW50ZXJjZXB0LWNvbnNvbGUtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vLi4vbGliL2lzLWVycm9yJ1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGhhbmRsZUNsaWVudEVycm9yIH0gZnJvbSAnLi4vcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy91c2UtZXJyb3ItaGFuZGxlcidcblxuZXhwb3J0IGNvbnN0IG9yaWdpbkNvbnNvbGVFcnJvciA9IHdpbmRvdy5jb25zb2xlLmVycm9yXG5cbi8vIFBhdGNoIGNvbnNvbGUuZXJyb3IgdG8gY29sbGVjdCBpbmZvcm1hdGlvbiBhYm91dCBoeWRyYXRpb24gZXJyb3JzXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25zb2xlRXJyb3IoKSB7XG4gIC8vIEVuc3VyZSBpdCdzIG9ubHkgcGF0Y2hlZCBvbmNlXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVyblxuICB9XG4gIHdpbmRvdy5jb25zb2xlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoLi4uYXJnczogYW55W10pIHtcbiAgICBsZXQgbWF5YmVFcnJvcjogdW5rbm93blxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCByZXBsYXllZEVycm9yID0gbWF0Y2hSZXBsYXllZEVycm9yKC4uLmFyZ3MpXG4gICAgICBpZiAocmVwbGF5ZWRFcnJvcikge1xuICAgICAgICBtYXliZUVycm9yID0gcmVwbGF5ZWRFcnJvclxuICAgICAgfSBlbHNlIGlmIChpc0Vycm9yKGFyZ3NbMF0pKSB7XG4gICAgICAgIG1heWJlRXJyb3IgPSBhcmdzWzBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvZDUwMzIzZWI4NDVjNWZkZTBkNzIwY2FlODg4YmYzNWRlZGQwNTUwNi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyRXJyb3JMb2dnZXIuanMjTDc4XG4gICAgICAgIG1heWJlRXJyb3IgPSBhcmdzWzFdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heWJlRXJyb3IgPSBhcmdzWzBdXG4gICAgfVxuXG4gICAgaWYgKCFpc05leHRSb3V0ZXJFcnJvcihtYXliZUVycm9yKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaGFuZGxlQ2xpZW50RXJyb3IoXG4gICAgICAgICAgLy8gcmVwbGF5ZWQgZXJyb3JzIGhhdmUgdGhlaXIgb3duIGNvbXBsZXggZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkLFxuICAgICAgICAgIC8vIGJ1dCBpZiB3ZSBwYXNzIHRoZSBlcnJvciBkaXJlY3RseSwgYGhhbmRsZUNsaWVudEVycm9yYCB3aWxsIGlnbm9yZSBpdFxuICAgICAgICAgIG1heWJlRXJyb3IsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgb3JpZ2luQ29uc29sZUVycm9yLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJlcGxheWVkRXJyb3IoLi4uYXJnczogdW5rbm93bltdKTogRXJyb3IgfCBudWxsIHtcbiAgLy8gU2VlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzY1YTU2ZDBlOTkyNjE0ODFjNzIxMzM0YTNlYzQ1NjFkMTczNTk0Y2QvcGFja2FnZXMvcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZsaWdodC9yZW5kZXJlci5qcyNMODgtTDkzXG4gIC8vXG4gIC8vIExvZ3MgcmVwbGF5ZWQgZnJvbSB0aGUgc2VydmVyIGxvb2sgbGlrZSB0aGlzOlxuICAvLyBbXG4gIC8vICAgXCIlYyVzJWMgJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gIC8vICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2OyAuLi5cIixcbiAgLy8gICBcIiBTZXJ2ZXIgXCIsIC8vIGNhbiBhbHNvIGJlIGUuZy4gXCIgUHJlcmVuZGVyIFwiXG4gIC8vICAgXCJcIixcbiAgLy8gICBFcnJvclxuICAvLyAgIFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8UGFnZT4gY29tcG9uZW50LlwiXG4gIC8vICAgLi4uXG4gIC8vIF1cbiAgaWYgKFxuICAgIGFyZ3MubGVuZ3RoID4gMyAmJlxuICAgIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJlxuICAgIGFyZ3NbMF0uc3RhcnRzV2l0aCgnJWMlcyVjICcpICYmXG4gICAgdHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGFyZ3NbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGFyZ3NbM10gPT09ICdzdHJpbmcnXG4gICkge1xuICAgIGNvbnN0IG1heWJlRXJyb3IgPSBhcmdzWzRdXG4gICAgaWYgKGlzRXJyb3IobWF5YmVFcnJvcikpIHtcbiAgICAgIHJldHVybiBtYXliZUVycm9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJvcmlnaW5Db25zb2xlRXJyb3IiLCJwYXRjaENvbnNvbGVFcnJvciIsIndpbmRvdyIsImNvbnNvbGUiLCJlcnJvciIsImFyZ3MiLCJtYXliZUVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVwbGF5ZWRFcnJvciIsIm1hdGNoUmVwbGF5ZWRFcnJvciIsImlzRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImhhbmRsZUNsaWVudEVycm9yIiwiYXBwbHkiLCJsZW5ndGgiLCJzdGFydHNXaXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            if (this.props.missingSlots.size > 0) {\n                const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(', ');\n                warningMessage += 'Missing slots: ' + formattedSlots;\n            }\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n}\nfunction HTTPAccessFallbackBoundary(param) {\n    let { notFound, forbidden, unauthorized, children } = param;\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs4REF3SmdCQTs7O2VBQUFBOzs7Ozs2RUEzSWtCO2lEQUNHO2dEQU05QjtzQ0FDa0I7MkRBQ1U7QUFxQm5DLE1BQU1DLHdDQUF3Q0MsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBWTNEQyxvQkFBMEI7UUFDeEIsSUFDRUMsS0FBb0IsSUFDcEIsSUFBSSxDQUFDRyxLQUFLLENBQUNDLFlBQVksSUFDdkIsNEVBQTRFO1FBQzVFLENBQUMsSUFBSSxDQUFDRCxLQUFLLENBQUNDLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLGFBQzdCO1lBQ0EsSUFBSUMsaUJBQ0YsNEhBQ0E7WUFFRixJQUFJLElBQUksQ0FBQ0gsS0FBSyxDQUFDQyxZQUFZLENBQUNHLElBQUksR0FBRyxHQUFHO2dCQUNwQyxNQUFNQyxpQkFBaUJDLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0MsWUFBWSxFQUN0RE8sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVFLGFBQWEsQ0FBQ0QsSUFDL0JFLEdBQUcsQ0FBQyxDQUFDQyxPQUFVLE1BQUdBLE1BQ2xCQyxJQUFJLENBQUM7Z0JBRVJYLGtCQUFrQixvQkFBb0JFO1lBQ3hDO1lBRUFVLENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQVNaO1FBQ1g7SUFDRjtJQUVBLE9BQU9hLHlCQUF5QkMsS0FBVSxFQUFFO1FBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSx5QkFBeUIsRUFBQ0QsUUFBUTtZQUNwQyxNQUFNRSxhQUFhQyxDQUFBQSxHQUFBQSxvQkFBQUEsMkJBQUFBLEVBQTRCSDtZQUMvQyxPQUFPO2dCQUNMSSxpQkFBaUJGO1lBQ25CO1FBQ0Y7UUFDQSxtQ0FBbUM7UUFDbkMsTUFBTUY7SUFDUjtJQUVBLE9BQU9LLHlCQUNMdEIsS0FBMkMsRUFDM0N1QixLQUE4QixFQUNFO1FBQ2hDOzs7OztLQUtDLEdBQ0QsSUFBSXZCLE1BQU13QixRQUFRLEtBQUtELE1BQU1FLGdCQUFnQixJQUFJRixNQUFNRixlQUFlLEVBQUU7WUFDdEUsT0FBTztnQkFDTEEsaUJBQWlCSztnQkFDakJELGtCQUFrQnpCLE1BQU13QixRQUFRO1lBQ2xDO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xILGlCQUFpQkUsTUFBTUYsZUFBZTtZQUN0Q0ksa0JBQWtCekIsTUFBTXdCLFFBQVE7UUFDbEM7SUFDRjtJQUVBRyxTQUFTO1FBQ1AsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMvQixLQUFLO1FBQ2xFLE1BQU0sRUFBRXFCLGVBQWUsRUFBRSxHQUFHLElBQUksQ0FBQ0UsS0FBSztRQUN0QyxNQUFNUyxrQkFBa0I7WUFDdEIsQ0FBQ0Msb0JBQUFBLHFCQUFxQixDQUFDQyxTQUFTLENBQUMsRUFBRU47WUFDbkMsQ0FBQ0ssb0JBQUFBLHFCQUFxQixDQUFDRSxTQUFTLENBQUMsRUFBRU47WUFDbkMsQ0FBQ0ksb0JBQUFBLHFCQUFxQixDQUFDRyxZQUFZLENBQUMsRUFBRU47UUFDeEM7UUFFQSxJQUFJVCxpQkFBaUI7WUFDbkIsTUFBTWdCLGFBQ0poQixvQkFBb0JZLG9CQUFBQSxxQkFBcUIsQ0FBQ0MsU0FBUyxJQUFJTjtZQUN6RCxNQUFNVSxjQUNKakIsb0JBQW9CWSxvQkFBQUEscUJBQXFCLENBQUNFLFNBQVMsSUFBSU47WUFDekQsTUFBTVUsaUJBQ0psQixvQkFBb0JZLG9CQUFBQSxxQkFBcUIsQ0FBQ0csWUFBWSxJQUFJTjtZQUU1RCxrR0FBa0c7WUFDbEcsSUFBSSxDQUFFTyxDQUFBQSxjQUFjQyxlQUFlQyxjQUFBQSxDQUFhLEVBQUk7Z0JBQ2xELE9BQU9SO1lBQ1Q7WUFFQSxxQkFDRTs7a0NBQ0UscUJBQUNTLFFBQUFBO3dCQUFLQyxNQUFLO3dCQUFTQyxTQUFROzt5QkFDVyxJQUFiLGNBQ3hCLHFCQUFDRixRQUFBQTt3QkFDQ0MsTUFBSzt3QkFDTEMsU0FBU0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtDQUFBQSxFQUFtQ3RCOztvQkFHL0NXLGVBQWUsQ0FBQ1gsZ0JBQWdCOzs7UUFHdkM7UUFFQSxPQUFPVTtJQUNUO0lBdEdBYSxZQUFZNUMsS0FBMkMsQ0FBRTtRQUN2RCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDdUIsS0FBSyxHQUFHO1lBQ1hGLGlCQUFpQks7WUFDakJELGtCQUFrQnpCLE1BQU13QixRQUFRO1FBQ2xDO0lBQ0Y7QUFpR0Y7QUFFTyxvQ0FBb0MsS0FLVDtJQUxTLE1BQ3pDSSxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsWUFBWSxFQUNaQyxRQUFRLEVBQ3dCLEdBTFM7SUFNekMsNkVBQTZFO0lBQzdFLHFFQUFxRTtJQUNyRSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLE1BQU1QLFdBQVdxQixDQUFBQSxHQUFBQSxxQkFBQUEsb0JBQUFBO0lBQ2pCLE1BQU01QyxlQUFlNkMsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MsK0JBQUFBLGtCQUFrQjtJQUNsRCxNQUFNQyxtQkFBbUIsQ0FBQyxDQUFFcEIsQ0FBQUEsWUFBWUMsYUFBYUMsWUFBQUEsQ0FBVztJQUVoRSxJQUFJa0Isa0JBQWtCO1FBQ3BCLE9BQ0UsV0FERixHQUNFLHFCQUFDdkQsaUNBQUFBO1lBQ0MrQixVQUFVQTtZQUNWSSxVQUFVQTtZQUNWQyxXQUFXQTtZQUNYQyxjQUFjQTtZQUNkN0IsY0FBY0E7c0JBRWI4Qjs7SUFHUDtJQUVBLHFCQUFPO2tCQUFHQTs7QUFDWjtLQTdCZ0J2QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcaHR0cC1hY2Nlc3MtZmFsbGJhY2tcXGVycm9yLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLyoqXG4gKiBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSBpcyBhIGJvdW5kYXJ5IHRoYXQgY2F0Y2hlcyBlcnJvcnMgYW5kIHJlbmRlcnMgYVxuICogZmFsbGJhY2sgY29tcG9uZW50IGZvciBIVFRQIGVycm9ycy5cbiAqXG4gKiBJdCByZWNlaXZlcyB0aGUgc3RhdHVzIGNvZGUsIGFuZCBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIHJlbmRlciBmYWxsYmFja3MgZm9yIGZldyBIVFRQIDR4eCBlcnJvcnMuXG4gKlxuICogZS5nLiA0MDRcbiAqIDQwNCByZXByZXNlbnRzIG5vdCBmb3VuZCwgYW5kIHRoZSBmYWxsYmFjayBjb21wb25lbnQgcGFpciBjb250YWlucyB0aGUgY29tcG9uZW50IGFuZCBpdHMgc3R5bGVzLlxuICpcbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVW50cmFja2VkUGF0aG5hbWUgfSBmcm9tICcuLi9uYXZpZ2F0aW9uLXVudHJhY2tlZCdcbmltcG9ydCB7XG4gIEhUVFBBY2Nlc3NFcnJvclN0YXR1cyxcbiAgZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzLFxuICBnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzLFxuICBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IE1pc3NpbmdTbG90Q29udGV4dCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG5pbnRlcmZhY2UgSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcyB7XG4gIG5vdEZvdW5kPzogUmVhY3QuUmVhY3ROb2RlXG4gIGZvcmJpZGRlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICB1bmF1dGhvcml6ZWQ/OiBSZWFjdC5SZWFjdE5vZGVcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICBtaXNzaW5nU2xvdHM/OiBTZXQ8c3RyaW5nPlxufVxuXG5pbnRlcmZhY2UgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzXG4gIGV4dGVuZHMgSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcyB7XG4gIHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB7XG4gIHRyaWdnZXJlZFN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIHByZXZpb3VzUGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbn1cblxuY2xhc3MgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRDYXRjaCgpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMgJiZcbiAgICAgIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICF0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5oYXMoJ2NoaWxkcmVuJylcbiAgICApIHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZSA9XG4gICAgICAgICdObyBkZWZhdWx0IGNvbXBvbmVudCB3YXMgZm91bmQgZm9yIGEgcGFyYWxsZWwgcm91dGUgcmVuZGVyZWQgb24gdGhpcyBwYWdlLiBGYWxsaW5nIGJhY2sgdG8gbmVhcmVzdCBOb3RGb3VuZCBib3VuZGFyeS5cXG4nICtcbiAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcGFyYWxsZWwtcm91dGVzI2RlZmF1bHRqc1xcblxcbidcblxuICAgICAgaWYgKHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFNsb3RzID0gQXJyYXkuZnJvbSh0aGlzLnByb3BzLm1pc3NpbmdTbG90cylcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKVxuICAgICAgICAgIC5tYXAoKHNsb3QpID0+IGBAJHtzbG90fWApXG4gICAgICAgICAgLmpvaW4oJywgJylcblxuICAgICAgICB3YXJuaW5nTWVzc2FnZSArPSAnTWlzc2luZyBzbG90czogJyArIGZvcm1hdHRlZFNsb3RzXG4gICAgICB9XG5cbiAgICAgIHdhcm5PbmNlKHdhcm5pbmdNZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyhlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogaHR0cFN0YXR1cyxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuICApOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB8IG51bGwge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLnRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0cmlnZ2VyZWRTdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBlcnJvckNvbXBvbmVudHMgPSB7XG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORF06IG5vdEZvdW5kLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU5dOiBmb3JiaWRkZW4sXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRF06IHVuYXV0aG9yaXplZCxcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICBjb25zdCBpc05vdEZvdW5kID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EICYmIG5vdEZvdW5kXG4gICAgICBjb25zdCBpc0ZvcmJpZGRlbiA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTiAmJiBmb3JiaWRkZW5cbiAgICAgIGNvbnN0IGlzVW5hdXRob3JpemVkID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEICYmIHVuYXV0aG9yaXplZFxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoZWQgYm91bmRhcnkgaW4gdGhpcyBsYXllciwga2VlcCB0aHJvd2luZyB0aGUgZXJyb3IgYnkgcmVuZGVyaW5nIHRoZSBjaGlsZHJlblxuICAgICAgaWYgKCEoaXNOb3RGb3VuZCB8fCBpc0ZvcmJpZGRlbiB8fCBpc1VuYXV0aG9yaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5cbiAgICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgKFxuICAgICAgICAgICAgPG1ldGFcbiAgICAgICAgICAgICAgbmFtZT1cIm5leHQtZXJyb3JcIlxuICAgICAgICAgICAgICBjb250ZW50PXtnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKHRyaWdnZXJlZFN0YXR1cyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2Vycm9yQ29tcG9uZW50c1t0cmlnZ2VyZWRTdGF0dXNdfVxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkoe1xuICBub3RGb3VuZCxcbiAgZm9yYmlkZGVuLFxuICB1bmF1dGhvcml6ZWQsXG4gIGNoaWxkcmVuLFxufTogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcykge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvciBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IG1pc3NpbmdTbG90cyA9IHVzZUNvbnRleHQoTWlzc2luZ1Nsb3RDb250ZXh0KVxuICBjb25zdCBoYXNFcnJvckZhbGxiYWNrID0gISEobm90Rm91bmQgfHwgZm9yYmlkZGVuIHx8IHVuYXV0aG9yaXplZClcblxuICBpZiAoaGFzRXJyb3JGYWxsYmFjaykge1xuICAgIHJldHVybiAoXG4gICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVxuICAgICAgICBwYXRobmFtZT17cGF0aG5hbWV9XG4gICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgZm9yYmlkZGVuPXtmb3JiaWRkZW59XG4gICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICBtaXNzaW5nU2xvdHM9e21pc3NpbmdTbG90c31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIkhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZENhdGNoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicHJvcHMiLCJtaXNzaW5nU2xvdHMiLCJoYXMiLCJ3YXJuaW5nTWVzc2FnZSIsInNpemUiLCJmb3JtYXR0ZWRTbG90cyIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJtYXAiLCJzbG90Iiwiam9pbiIsIndhcm5PbmNlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIiwiaHR0cFN0YXR1cyIsImdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyIsInRyaWdnZXJlZFN0YXR1cyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsInN0YXRlIiwicGF0aG5hbWUiLCJwcmV2aW91c1BhdGhuYW1lIiwidW5kZWZpbmVkIiwicmVuZGVyIiwibm90Rm91bmQiLCJmb3JiaWRkZW4iLCJ1bmF1dGhvcml6ZWQiLCJjaGlsZHJlbiIsImVycm9yQ29tcG9uZW50cyIsIkhUVFBBY2Nlc3NFcnJvclN0YXR1cyIsIk5PVF9GT1VORCIsIkZPUkJJRERFTiIsIlVOQVVUSE9SSVpFRCIsImlzTm90Rm91bmQiLCJpc0ZvcmJpZGRlbiIsImlzVW5hdXRob3JpemVkIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwiZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyIsImNvbnN0cnVjdG9yIiwidXNlVW50cmFja2VkUGF0aG5hbWUiLCJ1c2VDb250ZXh0IiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwiaGFzRXJyb3JGYWxsYmFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createInitialRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nfunction createInitialRouterState(param) {\n    let { initialFlightData, initialCanonicalUrlParts, initialParallelRoutes, location, couldBeIntercepted, postponed, prerendered } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    const isServer = !location;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const rsc = initialSeedData == null ? void 0 : initialSeedData[1];\n    var _initialSeedData_;\n    const loading = (_initialSeedData_ = initialSeedData == null ? void 0 : initialSeedData[3]) != null ? _initialSeedData_ : null;\n    const cache = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: isServer ? new Map() : initialParallelRoutes,\n        loading\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, initialTree, initialSeedData, initialHead);\n    }\n    var _ref;\n    const initialState = {\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (false) {}\n    return initialState;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NERBcUJnQkE7OztlQUFBQTs7OytDQWxCa0I7MkRBQ1k7Z0RBQ0c7Z0RBQ0Y7Z0RBQ087NkRBQ0c7K0NBQ2Q7QUFZcEMsU0FBU0EseUJBQXlCLEtBUVY7SUFSVSxNQUN2Q0MsaUJBQWlCLEVBQ2pCQyx3QkFBd0IsRUFDeEJDLHFCQUFxQixFQUNyQkMsUUFBUSxFQUNSQyxrQkFBa0IsRUFDbEJDLFNBQVMsRUFDVEMsV0FBVyxFQUNrQixHQVJVO0lBU3ZDLHNGQUFzRjtJQUN0RixrR0FBa0c7SUFDbEcsbUNBQW1DO0lBQ25DLE1BQU1DLHNCQUFzQk4seUJBQXlCTyxJQUFJLENBQUM7SUFDMUQsTUFBTUMsdUJBQXVCQyxDQUFBQSxHQUFBQSxtQkFBQUEsMEJBQUFBLEVBQTJCVixpQkFBaUIsQ0FBQyxFQUFFO0lBQzVFLE1BQU0sRUFDSlcsTUFBTUMsV0FBVyxFQUNqQkMsVUFBVUMsZUFBZSxFQUN6QkMsTUFBTUMsV0FBVyxFQUNsQixHQUFHUDtJQUNKLE1BQU1RLFdBQVcsQ0FBQ2Q7SUFDbEIsZ0dBQWdHO0lBQ2hHLGdEQUFnRDtJQUNoRCxNQUFNZSxNQUFNSixtQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsZUFBaUIsQ0FBQyxFQUFFO1FBQ2hCQTtJQUFoQixNQUFNSyxVQUFVTCxDQUFBQSxvQkFBQUEsbUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGVBQWlCLENBQUMsRUFBRSxZQUFwQkEsb0JBQXdCO0lBRXhDLE1BQU1NLFFBQW1CO1FBQ3ZCQyxVQUFVO1FBQ1ZIO1FBQ0FJLGFBQWE7UUFDYlAsTUFBTTtRQUNOUSxjQUFjO1FBQ2Qsb0pBQW9KO1FBQ3BKQyxnQkFBZ0JQLFdBQVcsSUFBSVEsUUFBUXZCO1FBQ3ZDaUI7SUFDRjtJQUVBLE1BQU1PLGVBQ0osNkVBQTZFLHFFQUNxRTtJQUNsSnZCLFdBRUl3QixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCeEIsWUFDbEJJO0lBRU5xQixDQUFBQSxHQUFBQSxpQ0FBQUEsd0NBQUFBLEVBQXlDaEIsYUFBYWM7SUFFdEQsTUFBTUcsZ0JBQWdCLElBQUlKO0lBRTFCLHlFQUF5RTtJQUN6RSxJQUFJdkIsMEJBQTBCLFFBQVFBLHNCQUFzQjRCLElBQUksS0FBSyxHQUFHO1FBQ3RFQyxDQUFBQSxHQUFBQSwrQkFBQUEsNkJBQUFBLEVBQ0VYLE9BQ0FZLFdBQ0FwQixhQUNBRSxpQkFDQUU7SUFFSjtRQXFCSTtJQW5CSixNQUFNa0IsZUFBZTtRQUNuQnZCLE1BQU1DO1FBQ05RO1FBQ0FTO1FBQ0FNLFNBQVM7WUFDUEMsYUFBYTtZQUNiQyxlQUFlO1lBQ2YsbUVBQW1FO1lBQ25FLGdGQUFnRjtZQUNoRkMsNEJBQTRCO1FBQzlCO1FBQ0FDLG1CQUFtQjtZQUNqQkMsT0FBTztZQUNQQyxnQkFBZ0I7WUFDaEJDLGNBQWM7WUFDZEMsY0FBYyxFQUFFO1FBQ2xCO1FBQ0FqQjtRQUNBa0IsU0FFRSxDQUFDWCxPQUFBQSxDQUFBQSxHQUFBQSxvQkFBQUEsZ0NBQUFBLEVBQWlDckIsaUJBQWdCVCxZQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxTQUFVMEMsUUFBQUEsQ0FBUSxZQUFuRVosT0FDRDtJQUNKO0lBRUEsSUFBSWEsS0FBa0QzQyxFQUFFLEVBaUN2RDtJQUVELE9BQU8rQjtBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEZsaWdodERhdGFQYXRoIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7IGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQsIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMgfSBmcm9tICcuL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQgeyBnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCB9IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhbFJvdXRlclN0YXRlUGFyYW1ldGVycyB7XG4gIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0czogc3RyaW5nW11cbiAgaW5pdGlhbFBhcmFsbGVsUm91dGVzOiBDYWNoZU5vZGVbJ3BhcmFsbGVsUm91dGVzJ11cbiAgaW5pdGlhbEZsaWdodERhdGE6IEZsaWdodERhdGFQYXRoW11cbiAgbG9jYXRpb246IExvY2F0aW9uIHwgbnVsbFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICBpbml0aWFsRmxpZ2h0RGF0YSxcbiAgaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzLFxuICBpbml0aWFsUGFyYWxsZWxSb3V0ZXMsXG4gIGxvY2F0aW9uLFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQsXG4gIHBvc3Rwb25lZCxcbiAgcHJlcmVuZGVyZWQsXG59OiBJbml0aWFsUm91dGVyU3RhdGVQYXJhbWV0ZXJzKSB7XG4gIC8vIFdoZW4gaW5pdGlhbGl6ZWQgb24gdGhlIHNlcnZlciwgdGhlIGNhbm9uaWNhbCBVUkwgaXMgcHJvdmlkZWQgYXMgYW4gYXJyYXkgb2YgcGFydHMuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgd2hlbiB0aGUgUlNDIHBheWxvYWQgc3RyZWFtZWQgdG8gdGhlIGNsaWVudCwgY3Jhd2xlcnMgZG9uJ3QgaW50ZXJwcmV0IGl0XG4gIC8vIGFzIGEgVVJMIHRoYXQgc2hvdWxkIGJlIGNyYXdsZWQuXG4gIGNvbnN0IGluaXRpYWxDYW5vbmljYWxVcmwgPSBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMuam9pbignLycpXG4gIGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhID0gZ2V0RmxpZ2h0RGF0YVBhcnRzRnJvbVBhdGgoaW5pdGlhbEZsaWdodERhdGFbMF0pXG4gIGNvbnN0IHtcbiAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICBzZWVkRGF0YTogaW5pdGlhbFNlZWREYXRhLFxuICAgIGhlYWQ6IGluaXRpYWxIZWFkLFxuICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgY29uc3QgaXNTZXJ2ZXIgPSAhbG9jYXRpb25cbiAgLy8gRm9yIHRoZSBTU1IgcmVuZGVyLCBzZWVkIGRhdGEgc2hvdWxkIGFsd2F5cyBiZSBhdmFpbGFibGUgKHdlIG9ubHkgc2VuZCBiYWNrIGEgYG51bGxgIHJlc3BvbnNlXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgYGxvYWRpbmdgIHNlZ21lbnQsIHByZS1QUFIuKVxuICBjb25zdCByc2MgPSBpbml0aWFsU2VlZERhdGE/LlsxXVxuICBjb25zdCBsb2FkaW5nID0gaW5pdGlhbFNlZWREYXRhPy5bM10gPz8gbnVsbFxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIC8vIFRoZSBjYWNoZSBnZXRzIHNlZWRlZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlci4gYGluaXRpYWxQYXJhbGxlbFJvdXRlc2AgZW5zdXJlcyB0aGUgY2FjaGUgZnJvbSB0aGUgZmlyc3QgcmVuZGVyIGlzIHRoZXJlIGR1cmluZyB0aGUgc2Vjb25kIHJlbmRlci5cbiAgICBwYXJhbGxlbFJvdXRlczogaXNTZXJ2ZXIgPyBuZXcgTWFwKCkgOiBpbml0aWFsUGFyYWxsZWxSb3V0ZXMsXG4gICAgbG9hZGluZyxcbiAgfVxuXG4gIGNvbnN0IGNhbm9uaWNhbFVybCA9XG4gICAgLy8gbG9jYXRpb24uaHJlZiBpcyByZWFkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBjYW5vbmljYWxVcmwgaW4gdGhlIGJyb3dzZXJcbiAgICAvLyBUaGlzIGlzIHNhZmUgdG8gZG8gYXMgY2Fub25pY2FsVXJsIGNhbid0IGJlIHJlbmRlcmVkLCBpdCdzIG9ubHkgdXNlZCB0byBjb250cm9sIHRoZSBoaXN0b3J5IHVwZGF0ZXMgaW4gdGhlIHVzZUVmZmVjdCBmdXJ0aGVyIGRvd24gaW4gdGhpcyBmaWxlLlxuICAgIGxvY2F0aW9uXG4gICAgICA/IC8vIHdpbmRvdy5sb2NhdGlvbiBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgVVJMIGJ1dCBoYXMgYWxsIHRoZSBmaWVsZHMgY3JlYXRlSHJlZkZyb21VcmwgbmVlZHMuXG4gICAgICAgIGNyZWF0ZUhyZWZGcm9tVXJsKGxvY2F0aW9uKVxuICAgICAgOiBpbml0aWFsQ2Fub25pY2FsVXJsXG5cbiAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyhpbml0aWFsVHJlZSwgY2Fub25pY2FsVXJsKVxuXG4gIGNvbnN0IHByZWZldGNoQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgUHJlZmV0Y2hDYWNoZUVudHJ5PigpXG5cbiAgLy8gV2hlbiB0aGUgY2FjaGUgaGFzbid0IGJlZW4gc2VlZGVkIHlldCB3ZSBmaWxsIHRoZSBjYWNoZSB3aXRoIHRoZSBoZWFkLlxuICBpZiAoaW5pdGlhbFBhcmFsbGVsUm91dGVzID09PSBudWxsIHx8IGluaXRpYWxQYXJhbGxlbFJvdXRlcy5zaXplID09PSAwKSB7XG4gICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gICAgICBjYWNoZSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGluaXRpYWxUcmVlLFxuICAgICAgaW5pdGlhbFNlZWREYXRhLFxuICAgICAgaW5pdGlhbEhlYWRcbiAgICApXG4gIH1cblxuICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgdHJlZTogaW5pdGlhbFRyZWUsXG4gICAgY2FjaGUsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBwdXNoUmVmOiB7XG4gICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgIC8vIEZpcnN0IHJlbmRlciBuZWVkcyB0byBwcmVzZXJ2ZSB0aGUgcHJldmlvdXMgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAgIC8vIHRvIGF2b2lkIGl0IGJlaW5nIG92ZXJ3cml0dGVuIG9uIG5hdmlnYXRpb24gYmFjay9mb3J3YXJkIHdpdGggTVBBIE5hdmlnYXRpb24uXG4gICAgICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogdHJ1ZSxcbiAgICB9LFxuICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICBhcHBseTogZmFsc2UsXG4gICAgICBvbmx5SGFzaENoYW5nZTogZmFsc2UsXG4gICAgICBoYXNoRnJhZ21lbnQ6IG51bGwsXG4gICAgICBzZWdtZW50UGF0aHM6IFtdLFxuICAgIH0sXG4gICAgY2Fub25pY2FsVXJsLFxuICAgIG5leHRVcmw6XG4gICAgICAvLyB0aGUgfHwgb3BlcmF0b3IgaXMgaW50ZW50aW9uYWwsIHRoZSBwYXRobmFtZSBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAoZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUoaW5pdGlhbFRyZWUpIHx8IGxvY2F0aW9uPy5wYXRobmFtZSkgPz9cbiAgICAgIG51bGwsXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgbG9jYXRpb24pIHtcbiAgICAvLyBTZWVkIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIHRoaXMgcGFnZSdzIGRhdGEuXG4gICAgLy8gVGhpcyBpcyB0byBwcmV2ZW50IG5lZWRsZXNzbHkgcmUtcHJlZmV0Y2hpbmcgYSBwYWdlIHRoYXQgaXMgYWxyZWFkeSByZXVzYWJsZSxcbiAgICAvLyBhbmQgd2lsbCBhdm9pZCB0cmlnZ2VyaW5nIGEgbG9hZGluZyBzdGF0ZS9kYXRhIGZldGNoIHN0YWxsIHdoZW4gbmF2aWdhdGluZyBiYWNrIHRvIHRoZSBwYWdlLlxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBkbyB0aGlzIGluIGRldmVsb3BtZW50IGJlY2F1c2UgbGlua3MgYXJlbid0IHByZWZldGNoZWQgaW4gZGV2ZWxvcG1lbnRcbiAgICAvLyBzbyBoYXZpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuIHByZWZldGNoL25vIHByZWZldGNoIHByb3ZpZGVzIGluY29uc2lzdGVudCBiZWhhdmlvciBiYXNlZCBvbiB3aGljaCBwYWdlXG4gICAgLy8gd2FzIGxvYWRlZCBmaXJzdC5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgYCR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9YCxcbiAgICAgIGxvY2F0aW9uLm9yaWdpblxuICAgIClcblxuICAgIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZsaWdodERhdGE6IFtub3JtYWxpemVkRmxpZ2h0RGF0YV0sXG4gICAgICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6ICEhY291bGRCZUludGVyY2VwdGVkLFxuICAgICAgICBwcmVyZW5kZXJlZCxcbiAgICAgICAgcG9zdHBvbmVkLFxuICAgICAgICAvLyBUT0RPOiBUaGUgaW5pdGlhbCBSU0MgcGF5bG9hZCBpbmNsdWRlcyBib3RoIHN0YXRpYyBhbmQgZHluYW1pYyBkYXRhXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIHJlc3BvbnNlLCBldmVuIGlmIFBQUiBpcyBlbmFibGVkLiBTbyBpZiB0aGVyZSdzIGFueVxuICAgICAgICAvLyBkeW5hbWljIGRhdGEgYXQgYWxsLCB3ZSBjYW4ndCBzZXQgYSBzdGFsZSB0aW1lLiBJbiB0aGUgZnV0dXJlIHdlIG1heVxuICAgICAgICAvLyBhZGQgYSB3YXkgdG8gc3BsaXQgYSBzaW5nbGUgRmxpZ2h0IHN0cmVhbSBpbnRvIHN0YXRpYyBhbmQgZHluYW1pY1xuICAgICAgICAvLyBwYXJ0cy4gQnV0IGluIHRoZSBtZWFudGltZSB3ZSBzaG91bGQgYXQgbGVhc3QgbWFrZSB0aGlzIHdvcmsgZm9yXG4gICAgICAgIC8vIGZ1bGx5IHN0YXRpYyBwYWdlcy5cbiAgICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICAgIH0sXG4gICAgICB0cmVlOiBpbml0aWFsU3RhdGUudHJlZSxcbiAgICAgIHByZWZldGNoQ2FjaGU6IGluaXRpYWxTdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgbmV4dFVybDogaW5pdGlhbFN0YXRlLm5leHRVcmwsXG4gICAgICBraW5kOiBwcmVyZW5kZXJlZCA/IFByZWZldGNoS2luZC5GVUxMIDogUHJlZmV0Y2hLaW5kLkFVVE8sXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBpbml0aWFsU3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUiLCJpbml0aWFsRmxpZ2h0RGF0YSIsImluaXRpYWxDYW5vbmljYWxVcmxQYXJ0cyIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsImxvY2F0aW9uIiwiY291bGRCZUludGVyY2VwdGVkIiwicG9zdHBvbmVkIiwicHJlcmVuZGVyZWQiLCJpbml0aWFsQ2Fub25pY2FsVXJsIiwiam9pbiIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwiZ2V0RmxpZ2h0RGF0YVBhcnRzRnJvbVBhdGgiLCJ0cmVlIiwiaW5pdGlhbFRyZWUiLCJzZWVkRGF0YSIsImluaXRpYWxTZWVkRGF0YSIsImhlYWQiLCJpbml0aWFsSGVhZCIsImlzU2VydmVyIiwicnNjIiwibG9hZGluZyIsImNhY2hlIiwibGF6eURhdGEiLCJwcmVmZXRjaFJzYyIsInByZWZldGNoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwiY2Fub25pY2FsVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicHJlZmV0Y2hDYWNoZSIsInNpemUiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInVuZGVmaW5lZCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiaW5pdGlhbFN0YXRlIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsIm9ubHlIYXNoQ2hhbmdlIiwiaGFzaEZyYWdtZW50Iiwic2VnbWVudFBhdGhzIiwibmV4dFVybCIsInBhdGhuYW1lIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidXJsIiwiVVJMIiwic2VhcmNoIiwib3JpZ2luIiwiY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZGF0YSIsImZsaWdodERhdGEiLCJzdGFsZVRpbWUiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsIkFVVE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hash.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction doMpaNavigation(url) {\n    return {\n        flightData: urlToUrlWithoutFlightMarker(url).toString(),\n        canonicalUrl: undefined,\n        couldBeIntercepted: false,\n        prerendered: false,\n        postponed: false,\n        staleTime: -1\n    };\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(flightRouterState))\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        var _res_headers_get;\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        const res = await createFetch(url, headers, fetchPriority);\n        const responseUrl = urlToUrlWithoutFlightMarker(res.url);\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeader = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeader !== null ? parseInt(staleTimeHeader, 10) : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        if (true) {\n            await (__webpack_require__(/*! ../react-dev-overlay/app/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n        const response = await createFromNextReadableStream(flightStream);\n        if ((0, _appbuildid.getAppBuildId)() !== response.b) {\n            return doMpaNavigation(res.url);\n        }\n        return {\n            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            canonicalUrl: canonicalUrl,\n            couldBeIntercepted: interception,\n            prerendered: response.S,\n            postponed,\n            staleTime\n        };\n    } catch (err) {\n        console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return {\n            flightData: url.toString(),\n            canonicalUrl: undefined,\n            couldBeIntercepted: false,\n            prerendered: false,\n            postponed: false,\n            staleTime: -1\n        };\n    }\n}\nfunction createFetch(url, headers, fetchPriority) {\n    const fetchUrl = new URL(url);\n    if (false) {}\n    // This is used to cache bust CDNs that don't support custom headers. The\n    // result is stored in a search param.\n    // TODO: Given that we have to use a search param anyway, we might as well\n    // _only_ use a search param and not bother with the custom headers.\n    // Add unique cache query to avoid caching conflicts on CDN which don't respect the Vary header\n    const uniqueCacheQuery = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(','));\n    fetchUrl.searchParams.set(_approuterheaders.NEXT_RSC_UNION_QUERY, uniqueCacheQuery);\n    if (false) {}\n    if (false) {}\n    return fetch(fetchUrl, {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined\n    });\n}\nfunction createFromNextReadableStream(flightStream) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQThOZ0JBLGFBQVc7ZUFBWEE7O0lBaURBQyw0QkFBNEI7ZUFBNUJBOztJQTVLTUMsbUJBQW1CO2VBQW5CQTs7SUFoQ05DLDJCQUEyQjtlQUEzQkE7Ozs4Q0F2Q1Q7MkNBQ29CO2lEQUNNO2dEQUNKO2tDQUNMOytDQUlqQjt3Q0FDdUI7QUFuQzlCLGFBQWE7QUFDYiw2REFBNkQ7QUFDN0QsNkVBQTZFO0FBQzdFLE1BQU0sRUFBRUMsd0JBQXdCLEVBQUUsR0FDaEMsTUFBMEIsR0FFdEJJLENBQStDLEdBRS9DQSxtQkFBT0EsQ0FBQyxpSUFBaUM7QUF5RHhDLFNBQVNMLDRCQUE0Qk0sR0FBVztJQUNyRCxNQUFNQyw2QkFBNkIsSUFBSUMsSUFBSUYsS0FBS0csU0FBU0MsTUFBTTtJQUMvREgsMkJBQTJCSSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0Msa0JBQUFBLG9CQUFvQjtJQUNuRSxJQUFJWCxLQUFvQixFQUFtQixFQVUxQztJQUNELE9BQU9LO0FBQ1Q7QUFFQSxTQUFTYSxnQkFBZ0JkLEdBQVc7SUFDbEMsT0FBTztRQUNMZSxZQUFZckIsNEJBQTRCTSxLQUFLZ0IsUUFBUTtRQUNyREMsY0FBY0M7UUFDZEMsb0JBQW9CO1FBQ3BCQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsV0FBVyxDQUFDO0lBQ2Q7QUFDRjtBQU1PLGVBQWU3QixvQkFDcEJPLEdBQVEsRUFDUnVCLE9BQW1DO0lBRW5DLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUVDLE9BQU8sRUFBRUMsWUFBWSxFQUFFLEdBQUdIO0lBRXJELE1BQU1JLFVBQTBCO1FBQzlCLHlCQUF5QjtRQUN6QixDQUFDQyxrQkFBQUEsVUFBVSxDQUFDLEVBQUU7UUFDZCxtQ0FBbUM7UUFDbkMsQ0FBQ0Msa0JB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QXVFO0lBQ3ZFLDBFQUEwRTtJQUMxRSw4REFBOEQ7SUFDOUQsMkNBQTJDO0lBQzNDLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsMEVBQTBFO0lBQzFFLDhFQUE4RTtJQUM5RSwrQkFBK0I7SUFDL0IsTUFBTUMsU0FBU0QscUJBQXFCRSxTQUFTO0lBQzdDLE9BQU8sSUFBSUMsZUFBZTtRQUN4QixNQUFNQyxNQUFLQyxVQUFVO1lBQ25CLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtnQkFDekMsSUFBSSxDQUFDRixNQUFNO29CQUNULG1FQUFtRTtvQkFDbkUsbUJBQW1CO29CQUNuQkQsV0FBV0ksT0FBTyxDQUFDRjtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EscUVBQXFFO2dCQUNyRSxxQkFBcUI7Z0JBQ3JCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJvdXRlci1yZWR1Y2VyXFxmZXRjaC1zZXJ2ZXItcmVzcG9uc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIEB0cy1pZ25vcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbi8vIGltcG9ydCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG5jb25zdCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSB9ID0gKFxuICAhIXByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRVxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuICAgICAgcmVxdWlyZSgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5lZGdlJylcbiAgICA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICAgIHJlcXVpcmUoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnKVxuKSBhcyB0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50JylcblxuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7XG4gIE5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbiAgTkVYVF9VUkwsXG4gIFJTQ19IRUFERVIsXG4gIFJTQ19DT05URU5UX1RZUEVfSEVBREVSLFxuICBORVhUX0hNUl9SRUZSRVNIX0hFQURFUixcbiAgTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUixcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoZXhIYXNoIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9oYXNoJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplRmxpZ2h0RGF0YSxcbiAgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbn0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IGdldEFwcEJ1aWxkSWQgfSBmcm9tICcuLi8uLi9hcHAtYnVpbGQtaWQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hTZXJ2ZXJSZXNwb25zZU9wdGlvbnMge1xuICByZWFkb25seSBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgcmVhZG9ubHkgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxuICByZWFkb25seSBwcmVmZXRjaEtpbmQ/OiBQcmVmZXRjaEtpbmRcbiAgcmVhZG9ubHkgaXNIbXJSZWZyZXNoPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0ID0ge1xuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nXG4gIGNhbm9uaWNhbFVybDogVVJMIHwgdW5kZWZpbmVkXG4gIGNvdWxkQmVJbnRlcmNlcHRlZDogYm9vbGVhblxuICBwcmVyZW5kZXJlZDogYm9vbGVhblxuICBwb3N0cG9uZWQ6IGJvb2xlYW5cbiAgc3RhbGVUaW1lOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdEhlYWRlcnMgPSB7XG4gIFtSU0NfSEVBREVSXT86ICcxJ1xuICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdPzogc3RyaW5nXG4gIFtORVhUX1VSTF0/OiBzdHJpbmdcbiAgW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0/OiAnMSdcbiAgW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXT86IHN0cmluZ1xuICAneC1kZXBsb3ltZW50LWlkJz86IHN0cmluZ1xuICBbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdPzogJzEnXG4gIC8vIEEgaGVhZGVyIHRoYXQgaXMgb25seSBhZGRlZCBpbiB0ZXN0IG1vZGUgdG8gYXNzZXJ0IG9uIGZldGNoIHByaW9yaXR5XG4gICdOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknPzogUmVxdWVzdEluaXRbJ3ByaW9yaXR5J11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmw6IHN0cmluZyk6IFVSTCB7XG4gIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbilcbiAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zLmRlbGV0ZShORVhUX1JTQ19VTklPTl9RVUVSWSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcgJiZcbiAgICAgIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnBhdGhuYW1lLmVuZHNXaXRoKCcudHh0JylcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzXG4gICAgICBjb25zdCBsZW5ndGggPSBwYXRobmFtZS5lbmRzV2l0aCgnL2luZGV4LnR4dCcpID8gMTAgOiA0XG4gICAgICAvLyBTbGljZSBvZmYgYC9pbmRleC50eHRgIG9yIGAudHh0YCBmcm9tIHRoZSBlbmQgb2YgdGhlIHBhdGhuYW1lXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDAsIC1sZW5ndGgpXG4gICAgfVxuICB9XG4gIHJldHVybiB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xufVxuXG5mdW5jdGlvbiBkb01wYU5hdmlnYXRpb24odXJsOiBzdHJpbmcpOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICBmbGlnaHREYXRhOiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsKS50b1N0cmluZygpLFxuICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgcHJlcmVuZGVyZWQ6IGZhbHNlLFxuICAgIHBvc3Rwb25lZDogZmFsc2UsXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIHRoZSBmbGlnaHQgZGF0YSBmb3IgdGhlIHByb3ZpZGVkIHVybC4gVGFrZXMgaW4gdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gKiB0byBkZWNpZGUgd2hhdCB0byByZW5kZXIgc2VydmVyLXNpZGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlclJlc3BvbnNlKFxuICB1cmw6IFVSTCxcbiAgb3B0aW9uczogRmV0Y2hTZXJ2ZXJSZXNwb25zZU9wdGlvbnNcbik6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD4ge1xuICBjb25zdCB7IGZsaWdodFJvdXRlclN0YXRlLCBuZXh0VXJsLCBwcmVmZXRjaEtpbmQgfSA9IG9wdGlvbnNcblxuICBjb25zdCBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAvLyBFbmFibGUgZmxpZ2h0IHJlc3BvbnNlXG4gICAgW1JTQ19IRUFERVJdOiAnMScsXG4gICAgLy8gUHJvdmlkZSB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGVcbiAgICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdOiBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSlcbiAgICApLFxuICB9XG5cbiAgLyoqXG4gICAqIFRocmVlIGNhc2VzOlxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGB1bmRlZmluZWRgLCBpdCBtZWFucyBpdCdzIGEgbm9ybWFsIG5hdmlnYXRpb24sIHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBmdWxsYCAtIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHdob2xlIHBhZ2Ugc28gc2FtZSBhcyBhYm92ZVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBhdXRvYCAtIGlmIHRoZSBwYWdlIGlzIGR5bmFtaWMsIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgcGFydGlhbGx5LCBpZiBzdGF0aWMgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKi9cbiAgaWYgKHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBvcHRpb25zLmlzSG1yUmVmcmVzaCkge1xuICAgIGhlYWRlcnNbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAobmV4dFVybCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgXCJ0ZW1wb3JhcnlcIiBwcmVmZXRjaCAodGhlIFwib24tZGVtYW5kXCIgcHJlZmV0Y2ggdGhhdCBnZXRzIGNyZWF0ZWQgb24gbmF2aWdhdGlvbiwgaWYgb25lIGRvZXNuJ3QgZXhpc3QpXG4gICAgLy8gd2Ugc2VuZCB0aGUgcmVxdWVzdCB3aXRoIGEgXCJoaWdoXCIgcHJpb3JpdHkgYXMgaXQncyBpbiByZXNwb25zZSB0byBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCBjb3VsZCBiZSBibG9ja2luZyBhIHRyYW5zaXRpb24uXG4gICAgLy8gT3RoZXJ3aXNlLCBhbGwgb3RoZXIgcHJlZmV0Y2hlcyBhcmUgc2VudCB3aXRoIGEgXCJsb3dcIiBwcmlvcml0eS5cbiAgICAvLyBXZSB1c2UgXCJhdXRvXCIgZm9yIGluIGFsbCBvdGhlciBjYXNlcyB0byBtYXRjaCB0aGUgZXhpc3RpbmcgZGVmYXVsdCwgYXMgdGhpcyBmdW5jdGlvbiBpcyBzaGFyZWQgb3V0c2lkZSBvZiBwcmVmZXRjaGluZy5cbiAgICBjb25zdCBmZXRjaFByaW9yaXR5ID0gcHJlZmV0Y2hLaW5kXG4gICAgICA/IHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWVxuICAgICAgICA/ICdoaWdoJ1xuICAgICAgICA6ICdsb3cnXG4gICAgICA6ICdhdXRvJ1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3JlYXRlRmV0Y2godXJsLCBoZWFkZXJzLCBmZXRjaFByaW9yaXR5KVxuXG4gICAgY29uc3QgcmVzcG9uc2VVcmwgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybClcbiAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHJlc3BvbnNlVXJsIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJydcbiAgICBjb25zdCBpbnRlcmNlcHRpb24gPSAhIXJlcy5oZWFkZXJzLmdldCgndmFyeScpPy5pbmNsdWRlcyhORVhUX1VSTClcbiAgICBjb25zdCBwb3N0cG9uZWQgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lSGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSKVxuICAgIGNvbnN0IHN0YWxlVGltZSA9XG4gICAgICBzdGFsZVRpbWVIZWFkZXIgIT09IG51bGwgPyBwYXJzZUludChzdGFsZVRpbWVIZWFkZXIsIDEwKSA6IC0xXG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBJZiB0aGUgZmV0Y2ggd2FzIG5vdCAyMDAsIHdlIGFsc28gaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rIHx8ICFyZXMuYm9keSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3JpZ2luYWwgVVJMIGNhbWUgd2l0aCBhIGhhc2gsIHByZXNlcnZlIGl0IGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgbmV3IFVSTFxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIHJlc3BvbnNlVXJsLmhhc2ggPSB1cmwuaGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IG5hdmlnYXRlIHRvIGEgcGFnZSB0aGF0IHJlcXVpcmVzIGEgZGlmZmVyZW50IFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBwcm9kLCBldmVyeSBwYWdlIHdpbGwgaGF2ZSB0aGUgc2FtZSBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gZGV2LCB0aGUgV2VicGFjayBydW50aW1lIGlzIG1pbmltYWwgZm9yIGVhY2ggcGFnZS5cbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgV2VicGFjayBydW50aW1lIGlzIHVwZGF0ZWQgYmVmb3JlIGV4ZWN1dGluZyBjbGllbnQtc2lkZSBKUyBvZiB0aGUgbmV3IHBhZ2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgYXdhaXQgcmVxdWlyZSgnLi4vcmVhY3QtZGV2LW92ZXJsYXkvYXBwL2hvdC1yZWxvYWRlci1jbGllbnQnKS53YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUoKVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgIGNvbnN0IGZsaWdodFN0cmVhbSA9IHBvc3Rwb25lZFxuICAgICAgPyBjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbShyZXMuYm9keSlcbiAgICAgIDogcmVzLmJvZHlcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtKFxuICAgICAgZmxpZ2h0U3RyZWFtXG4gICAgKSBhcyBQcm9taXNlPE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZT4pXG5cbiAgICBpZiAoZ2V0QXBwQnVpbGRJZCgpICE9PSByZXNwb25zZS5iKSB7XG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlcy51cmwpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogaW50ZXJjZXB0aW9uLFxuICAgICAgcHJlcmVuZGVyZWQ6IHJlc3BvbnNlLlMsXG4gICAgICBwb3N0cG9uZWQsXG4gICAgICBzdGFsZVRpbWUsXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEZhaWxlZCB0byBmZXRjaCBSU0MgcGF5bG9hZCBmb3IgJHt1cmx9LiBGYWxsaW5nIGJhY2sgdG8gYnJvd3NlciBuYXZpZ2F0aW9uLmAsXG4gICAgICBlcnJcbiAgICApXG4gICAgLy8gSWYgZmV0Y2ggZmFpbHMgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQzNjA1I2lzc3VlY29tbWVudC0xNDUxNjE3NTIxIGZvciBhIHJlcHJvZHVjdGlvbi5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogdXJsLnRvU3RyaW5nKCksXG4gICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZldGNoKFxuICB1cmw6IFVSTCxcbiAgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMsXG4gIGZldGNoUHJpb3JpdHk6ICdhdXRvJyB8ICdoaWdoJyB8ICdsb3cnIHwgbnVsbFxuKSB7XG4gIGNvbnN0IGZldGNoVXJsID0gbmV3IFVSTCh1cmwpXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnKSB7XG4gICAgICBpZiAoZmV0Y2hVcmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBmZXRjaFVybC5wYXRobmFtZSArPSAnaW5kZXgudHh0J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hVcmwucGF0aG5hbWUgKz0gJy50eHQnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIGNhY2hlIGJ1c3QgQ0ROcyB0aGF0IGRvbid0IHN1cHBvcnQgY3VzdG9tIGhlYWRlcnMuIFRoZVxuICAvLyByZXN1bHQgaXMgc3RvcmVkIGluIGEgc2VhcmNoIHBhcmFtLlxuICAvLyBUT0RPOiBHaXZlbiB0aGF0IHdlIGhhdmUgdG8gdXNlIGEgc2VhcmNoIHBhcmFtIGFueXdheSwgd2UgbWlnaHQgYXMgd2VsbFxuICAvLyBfb25seV8gdXNlIGEgc2VhcmNoIHBhcmFtIGFuZCBub3QgYm90aGVyIHdpdGggdGhlIGN1c3RvbSBoZWFkZXJzLlxuICAvLyBBZGQgdW5pcXVlIGNhY2hlIHF1ZXJ5IHRvIGF2b2lkIGNhY2hpbmcgY29uZmxpY3RzIG9uIENETiB3aGljaCBkb24ndCByZXNwZWN0IHRoZSBWYXJ5IGhlYWRlclxuICBjb25zdCB1bmlxdWVDYWNoZVF1ZXJ5ID0gaGV4SGFzaChcbiAgICBbXG4gICAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl0sXG4gICAgICBoZWFkZXJzW05FWFRfVVJMXSxcbiAgICBdLmpvaW4oJywnKVxuICApXG5cbiAgZmV0Y2hVcmwuc2VhcmNoUGFyYW1zLnNldChORVhUX1JTQ19VTklPTl9RVUVSWSwgdW5pcXVlQ2FjaGVRdWVyeSlcblxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSAmJiBmZXRjaFByaW9yaXR5ICE9PSBudWxsKSB7XG4gICAgaGVhZGVyc1snTmV4dC1UZXN0LUZldGNoLVByaW9yaXR5J10gPSBmZXRjaFByaW9yaXR5XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEKSB7XG4gICAgaGVhZGVyc1sneC1kZXBsb3ltZW50LWlkJ10gPSBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgfVxuXG4gIHJldHVybiBmZXRjaChmZXRjaFVybCwge1xuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIG9sZGVyIGJyb3dzZXJzLiBgc2FtZS1vcmlnaW5gIGlzIHRoZSBkZWZhdWx0IGluIG1vZGVybiBicm93c2Vycy5cbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBoZWFkZXJzLFxuICAgIHByaW9yaXR5OiBmZXRjaFByaW9yaXR5IHx8IHVuZGVmaW5lZCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gIGZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKGZsaWdodFN0cmVhbSwge1xuICAgIGNhbGxTZXJ2ZXIsXG4gICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0oXG4gIG9yaWdpbmFsRmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCBwcmVmZXRjaCBzdHJlYW1zIG1heSBjb250YWluIHJlZmVyZW5jZXMgdGhhdCBuZXZlclxuICAvLyByZXNvbHZlLCBiZWNhdXNlIHRoYXQncyBob3cgd2UgZW5jb2RlIGR5bmFtaWMgZGF0YSBhY2Nlc3MuIEluIHRoZSBkZWNvZGVkXG4gIC8vIG9iamVjdCByZXR1cm5lZCBieSB0aGUgRmxpZ2h0IGNsaWVudCwgdGhlc2UgYXJlIHJlaWZpZWQgaW50byBoYW5naW5nXG4gIC8vIHByb21pc2VzIHRoYXQgc3VzcGVuZCBkdXJpbmcgcmVuZGVyLCB3aGljaCBpcyBlZmZlY3RpdmVseSB3aGF0IHdlIHdhbnQuXG4gIC8vIFRoZSBVSSByZXNvbHZlcyB3aGVuIGl0IHN3aXRjaGVzIHRvIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtXG4gIC8vICh2aWEgdXNlRGVmZXJyZWRWYWx1ZShkeW5hbWljLCBzdGF0aWMpKS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgdGhlIEZsaWdodCBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZXJyb3JzIGlmIHRoZSBzZXJ2ZXIgY2xvc2VzXG4gIC8vIHRoZSByZXNwb25zZSBiZWZvcmUgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gQXMgYSBjaGVhdCB0byB3b3JrXG4gIC8vIGFyb3VuZCB0aGlzLCB3ZSB3cmFwIHRoZSBvcmlnaW5hbCBzdHJlYW0gaW4gYSBuZXcgc3RyZWFtIHRoYXQgbmV2ZXIgY2xvc2VzLFxuICAvLyBhbmQgdGhlcmVmb3JlIGRvZXNuJ3QgZXJyb3IuXG4gIGNvbnN0IHJlYWRlciA9IG9yaWdpbmFsRmxpZ2h0U3RyZWFtLmdldFJlYWRlcigpXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAvLyBQYXNzIHRvIHRoZSB0YXJnZXQgc3RyZWFtIGFuZCBrZWVwIGNvbnN1bWluZyB0aGUgRmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVGZXRjaCIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInJlcXVpcmUiLCJ1cmwiLCJ1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJOT0RFX0VOViIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZG9NcGFOYXZpZ2F0aW9uIiwiZmxpZ2h0RGF0YSIsInRvU3RyaW5nIiwiY2Fub25pY2FsVXJsIiwidW5kZWZpbmVkIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJvcHRpb25zIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwicHJlZmV0Y2hLaW5kIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiaXNIbXJSZWZyZXNoIiwiTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIiLCJORVhUX1VSTCIsInJlcyIsImZldGNoUHJpb3JpdHkiLCJURU1QT1JBUlkiLCJyZXNwb25zZVVybCIsInJlZGlyZWN0ZWQiLCJjb250ZW50VHlwZSIsImdldCIsImludGVyY2VwdGlvbiIsImluY2x1ZGVzIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwic3RhbGVUaW1lSGVhZGVyIiwiTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIiLCJwYXJzZUludCIsImlzRmxpZ2h0UmVzcG9uc2UiLCJzdGFydHNXaXRoIiwiUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIiLCJvayIsImJvZHkiLCJoYXNoIiwiVFVSQk9QQUNLIiwid2FpdEZvcldlYnBhY2tSdW50aW1lSG90VXBkYXRlIiwiZmxpZ2h0U3RyZWFtIiwiY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0iLCJyZXNwb25zZSIsImdldEFwcEJ1aWxkSWQiLCJiIiwibm9ybWFsaXplRmxpZ2h0RGF0YSIsImYiLCJTIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiZmV0Y2hVcmwiLCJ1bmlxdWVDYWNoZVF1ZXJ5IiwiaGV4SGFzaCIsIk5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSIiwiam9pbiIsInNldCIsIl9fTkVYVF9URVNUX01PREUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwicHJpb3JpdHkiLCJjYWxsU2VydmVyIiwiZmluZFNvdXJjZU1hcFVSTCIsIm9yaWdpbmFsRmxpZ2h0U3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJlbnF1ZXVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSegmentMismatch\", ({\n    enumerable: true,\n    get: function() {\n        return handleSegmentMismatch;\n    }\n}));\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nfunction handleSegmentMismatch(state, action, treePatch) {\n    if (true) {\n        console.warn('Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' + 'Reason: Segment mismatch\\n' + (\"Last Action: \" + action.type + \"\\n\\n\") + (\"Current Tree: \" + JSON.stringify(state.tree) + \"\\n\\n\") + (\"Tree Patch Payload: \" + JSON.stringify(treePatch)));\n    }\n    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=handle-segment-mismatch.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozt5REFXZ0JBOzs7ZUFBQUE7Ozs2Q0FWa0I7QUFVM0IsU0FBU0Esc0JBQ2RDLEtBQTJCLEVBQzNCQyxNQUFzQixFQUN0QkMsU0FBNEI7SUFFNUIsSUFBSUMsSUFBb0IsRUFBb0I7UUFDMUNHLFFBQVFDLElBQUksQ0FDVixzSkFDRSwrQkFDQSxDQUFDLGtCQUFlTixPQUFPTyxJQUFJLEdBQUMsT0FBSSxJQUNoQyxtQkFBaUJDLEtBQUtDLFNBQVMsQ0FBQ1YsTUFBTVcsSUFBSSxJQUFFLE9BQUksSUFDaEQseUJBQXVCRixLQUFLQyxTQUFTLENBQUNSLFVBQUFBLENBQVc7SUFFdkQ7SUFFQSxPQUFPVSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQWtCWixPQUFPLENBQUMsR0FBR0EsTUFBTWEsWUFBWSxFQUFFO0FBQzFEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxcaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyQWN0aW9ucyxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHRoZSBjbGllbnQgcm91dGVyIGF0dGVtcHRlZCB0byBwYXRjaCB0aGUgdHJlZSBidXQsIGR1ZSB0byBhIG1pc21hdGNoLCB0aGUgcGF0Y2ggZmFpbGVkLlxuICogVGhpcyB3aWxsIHBlcmZvcm0gYW4gTVBBIG5hdmlnYXRpb24gdG8gcmV0dXJuIHRoZSByb3V0ZXIgdG8gYSB2YWxpZCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlZHVjZXJBY3Rpb25zLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1BlcmZvcm1pbmcgaGFyZCBuYXZpZ2F0aW9uIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBleHBlcmllbmNlZCBhbiB1bnJlY292ZXJhYmxlIGVycm9yLiBJZiB0aGlzIGtlZXBzIG9jY3VycmluZywgcGxlYXNlIGZpbGUgYSBOZXh0LmpzIGlzc3VlLlxcblxcbicgK1xuICAgICAgICAnUmVhc29uOiBTZWdtZW50IG1pc21hdGNoXFxuJyArXG4gICAgICAgIGBMYXN0IEFjdGlvbjogJHthY3Rpb24udHlwZX1cXG5cXG5gICtcbiAgICAgICAgYEN1cnJlbnQgVHJlZTogJHtKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKX1cXG5cXG5gICtcbiAgICAgICAgYFRyZWUgUGF0Y2ggUGF5bG9hZDogJHtKU09OLnN0cmluZ2lmeSh0cmVlUGF0Y2gpfWBcbiAgICApXG4gIH1cblxuICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIHt9LCBzdGF0ZS5jYW5vbmljYWxVcmwsIHRydWUpXG59XG4iXSwibmFtZXMiOlsiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwic3RhdGUiLCJhY3Rpb24iLCJ0cmVlUGF0Y2giLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwid2FybiIsInR5cGUiLCJKU09OIiwic3RyaW5naWZ5IiwidHJlZSIsImhhbmRsZUV4dGVybmFsVXJsIiwiY2Fub25pY2FsVXJsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNFFnQkEsOEJBQThCO2VBQTlCQTs7SUE5R0FDLDZCQUE2QjtlQUE3QkE7O0lBK05BQyxrQkFBa0I7ZUFBbEJBOzs7aURBMVhUO2dEQU1BOzZDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQixJQUFJQyxrQkFBa0JILElBQUlJLFFBQVE7SUFFbEMsNEZBQTRGO0lBQzVGLDhEQUE4RDtJQUM5RCxxRkFBcUY7SUFDckYsZ0ZBQWdGO0lBQ2hGLHFEQUFxRDtJQUNyRCxJQUFJSCxxQkFBcUI7UUFDdkIsMEVBQTBFO1FBQzFFLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUNFLG1CQUFtQkgsSUFBSUssTUFBTTtJQUMvQjtJQUVBLElBQUlILFFBQVE7UUFDVixPQUFRLEtBQUVBLFNBQVNKLGdDQUFnQ0s7SUFDckQ7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0csdUJBQ1BOLEdBQVEsRUFDUk8sSUFBOEIsRUFDOUJDLE9BQXVCO0lBRXZCLE9BQU9ULDJCQUEyQkMsS0FBS08sU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFRjtBQUNyRTtBQUVBLFNBQVNHLHNCQUNQWCxHQUFRLEVBQ1JPLElBQTJDLEVBQzNDQyxPQUFzQixFQUN0QkksYUFBOEMsRUFDOUNDLGFBQXNCO0lBSHRCTixJQUFBQSxTQUFBQSxLQUFBQSxHQUFBQSxPQUFxQkUsb0JBQUFBLFlBQVksQ0FBQ0ssU0FBUztJQUszQyw4RUFBOEU7SUFDOUUsa0pBQWtKO0lBQ2xKLGlJQUFp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QUkxRCxTQUFTRSxvQkFBQUEsWUFBWSxDQUFDeUUsSUFBSSxFQUFFO1FBQzlCLElBQUl0QixLQUFLQyxHQUFHLEtBQUtGLGVBQWVtQixxQkFBcUI7WUFDbkQsT0FBT2Qsb0JBQUFBLHdCQUF3QixDQUFDZ0IsS0FBSztRQUN2QztJQUNGO0lBRUEsaUdBQWlHO0lBQ2pHLElBQUl6RSxTQUFTRSxvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEVBQUU7UUFDOUIsSUFBSWtELEtBQUtDLEdBQUcsS0FBS0YsZUFBZW1CLHFCQUFxQjtZQUNuRCxPQUFPZCxvQkFBQUEsd0JBQXdCLENBQUNpQixRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPakIsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPO0FBQ3pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxyb3V0ZXItcmVkdWNlclxccHJlZmV0Y2gtY2FjaGUtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZmV0Y2hTZXJ2ZXJSZXNwb25zZSxcbiAgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0LFxufSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7XG4gIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyxcbiAgdHlwZSBQcmVmZXRjaENhY2hlRW50cnksXG4gIFByZWZldGNoS2luZCxcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IHByZWZldGNoUXVldWUgfSBmcm9tICcuL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXInXG5cbmNvbnN0IElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSID0gJyUnXG5cbmV4cG9ydCB0eXBlIEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgPSBQcmVmZXRjaENhY2hlRW50cnkgJiB7XG4gIC8qKiBUaGlzIGlzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyBhIHByZWZldGNoIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCBVUkxcbiAgICogd2FzIHJldHVybmVkIHJhdGhlciB0aGFuIHRoZSByZXF1ZXN0ZWQgVVJMLiBUaGlzIHNpZ25hbHMgdG8gdGhlIHJvdXRlciB0aGF0IGl0IHNob3VsZCBvbmx5XG4gICAqIGFwcGx5IHRoZSBwYXJ0IHRoYXQgZG9lc24ndCBkZXBlbmQgb24gc2VhcmNoUGFyYW1zIChzcGVjaWZpY2FsbHkgdGhlIGxvYWRpbmcgc3RhdGUpLlxuICAgKi9cbiAgYWxpYXNlZD86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2FjaGUga2V5IGZvciB0aGUgcm91dGVyIHByZWZldGNoIGNhY2hlXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYmVpbmcgbmF2aWdhdGVkIHRvXG4gKiBAcGFyYW0gbmV4dFVybCAtIGFuIGludGVybmFsIFVSTCwgcHJpbWFyaWx5IHVzZWQgZm9yIGhhbmRsaW5nIHJld3JpdGVzLiBEZWZhdWx0cyB0byAnLycuXG4gKiBAcmV0dXJuIFRoZSBnZW5lcmF0ZWQgcHJlZmV0Y2ggY2FjaGUga2V5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgdXJsOiBVUkwsXG4gIGluY2x1ZGVTZWFyY2hQYXJhbXM6IGJvb2xlYW4sXG4gIHByZWZpeD86IHN0cmluZyB8IG51bGxcbikge1xuICAvLyBJbml0aWFsbHkgd2Ugb25seSB1c2UgdGhlIHBhdGhuYW1lIGFzIHRoZSBjYWNoZSBrZXkuIFdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZVxuICAvLyBzZWFyY2ggcGFyYW1zIHNvIHRoYXQgbXVsdGlwbGUgVVJMcyB3aXRoIHRoZSBzYW1lIHNlYXJjaCBwYXJhbWV0ZXIgY2FuIHJlLXVzZVxuICAvLyBsb2FkaW5nIHN0YXRlcy5cbiAgbGV0IHBhdGhuYW1lRnJvbVVybCA9IHVybC5wYXRobmFtZVxuXG4gIC8vIFJTQyByZXNwb25zZXMgY2FuIGRpZmZlciBiYXNlZCBvbiBzZWFyY2ggcGFyYW1zLCBzcGVjaWZpY2FsbHkgaW4gdGhlIGNhc2Ugd2hlcmUgd2UgYXJlbid0XG4gIC8vIHJldHVybmluZyBhIHBhcnRpYWwgcmVzcG9uc2UgKGllIHdpdGggYFByZWZldGNoS2luZC5BVVRPYCkuXG4gIC8vIEluIHRoZSBhdXRvIGNhc2UsIHNpbmNlIGxvYWRpbmcuanMgJiBsYXlvdXQuanMgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gc2VhcmNoIHBhcmFtcyxcbiAgLy8gd2UgY2FuIHNhZmVseSByZS11c2UgdGhhdCBjYWNoZSBlbnRyeS4gQnV0IGZvciBmdWxsIHByZWZldGNoZXMsIHdlIHNob3VsZCBub3RcbiAgLy8gcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBhcyB0aGUgcmVzcG9uc2UgbWF5IGRpZmZlci5cbiAgaWYgKGluY2x1ZGVTZWFyY2hQYXJhbXMpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIGluY2x1ZGUgdGhlIHNlYXJjaCBwYXJhbSBpbiB0aGUga2V5LFxuICAgIC8vIGFzIHdlJ2xsIGJlIGdldHRpbmcgYmFjayBhIGZ1bGwgcmVzcG9uc2UuIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSByZWFkIHRoZSBzZWFyY2hcbiAgICAvLyBwYXJhbXMgd2hlbiBnZW5lcmF0aW5nIHRoZSBmdWxsIHJlc3BvbnNlLlxuICAgIHBhdGhuYW1lRnJvbVVybCArPSB1cmwuc2VhcmNoXG4gIH1cblxuICBpZiAocHJlZml4KSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke0lOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSfSR7cGF0aG5hbWVGcm9tVXJsfWBcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZUZyb21Vcmxcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCB8IHVuZGVmaW5lZCxcbiAgbmV4dFVybD86IHN0cmluZyB8IG51bGxcbikge1xuICByZXR1cm4gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwodXJsLCBraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCwgbmV4dFVybClcbn1cblxuZnVuY3Rpb24gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICB1cmw6IFVSTCxcbiAga2luZDogUHJlZmV0Y2hLaW5kID0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgcHJlZmV0Y2hDYWNoZTogTWFwPHN0cmluZywgUHJlZmV0Y2hDYWNoZUVudHJ5PixcbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxuKTogQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZCB7XG4gIC8vIFdlIGZpcnN0IGNoZWNrIGlmIHRoZXJlJ3MgYSBtb3JlIHNwZWNpZmljIGludGVyY2VwdGlvbiByb3V0ZSBwcmVmZXRjaCBlbnRyeVxuICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2hlbiB3ZSBkZXRlY3QgYSBwcmVmZXRjaCB0aGF0IGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSBwcmVmaXggaXQgd2l0aCBuZXh0VXJsIChzZWUgYGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlgKVxuICAvLyB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBvdGhlciBwYWdlcyB0aGF0IG1heSBoYXZlIHRoZSBzYW1lIFVSTCBidXQgcmVuZGVyIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBgTmV4dC1VUkxgIGhlYWRlci5cbiAgZm9yIChjb25zdCBtYXliZU5leHRVcmwgb2YgW25leHRVcmwsIG51bGxdKSB7XG4gICAgY29uc3QgY2FjaGVLZXlXaXRoUGFyYW1zID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gICAgICB1cmwsXG4gICAgICB0cnVlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuICAgIGNvbnN0IGNhY2hlS2V5V2l0aG91dFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgZmFsc2UsXG4gICAgICBtYXliZU5leHRVcmxcbiAgICApXG5cbiAgICAvLyBGaXJzdCwgd2UgY2hlY2sgaWYgd2UgaGF2ZSBhIGNhY2hlIGVudHJ5IHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSBVUkxcbiAgICBjb25zdCBjYWNoZUtleVRvVXNlID0gdXJsLnNlYXJjaFxuICAgICAgPyBjYWNoZUtleVdpdGhQYXJhbXNcbiAgICAgIDogY2FjaGVLZXlXaXRob3V0UGFyYW1zXG5cbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlUb1VzZSlcbiAgICBpZiAoZXhpc3RpbmdFbnRyeSAmJiBhbGxvd0FsaWFzaW5nKSB7XG4gICAgICAvLyBXZSBrbm93IHdlJ3JlIHJldHVybmluZyBhbiBhbGlhc2VkIGVudHJ5IHdoZW4gdGhlIHBhdGhuYW1lIG1hdGNoZXMgYnV0IHRoZSBzZWFyY2ggcGFyYW1zIGRvbid0LFxuICAgICAgY29uc3QgaXNBbGlhc2VkID1cbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwucGF0aG5hbWUgPT09IHVybC5wYXRobmFtZSAmJlxuICAgICAgICBleGlzdGluZ0VudHJ5LnVybC5zZWFyY2ggIT09IHVybC5zZWFyY2hcblxuICAgICAgaWYgKGlzQWxpYXNlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nRW50cnksXG4gICAgICAgICAgYWxpYXNlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXF1ZXN0IGNvbnRhaW5zIHNlYXJjaCBwYXJhbXMsIGFuZCB3ZSdyZSBub3QgZG9pbmcgYSBmdWxsIHByZWZldGNoLCB3ZSBjYW4gcmV0dXJuIHRoZVxuICAgIC8vIHBhcmFtLWxlc3MgZW50cnkgaWYgaXQgZXhpc3RzLlxuICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgY292ZXJlZCBieSB0aGUgY2hlY2sgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZ1bmN0aW9uLCB3aGljaCBpdGVyYXRlcyBvdmVyIGNhY2hlIGVudHJpZXMsXG4gICAgLy8gYnV0IGxldHMgdXMgYXJyaXZlIHRoZXJlIHF1aWNrZXIgaW4gdGhlIHBhcmFtLWZ1bGwgY2FzZS5cbiAgICBjb25zdCBlbnRyeVdpdGhvdXRQYXJhbXMgPSBwcmVmZXRjaENhY2hlLmdldChjYWNoZUtleVdpdGhvdXRQYXJhbXMpXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIGFsbG93QWxpYXNpbmcgJiZcbiAgICAgIHVybC5zZWFyY2ggJiZcbiAgICAgIGtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgICBlbnRyeVdpdGhvdXRQYXJhbXMgJiZcbiAgICAgIC8vIFdlIHNob3VsZG4ndCByZXR1cm4gdGhlIGFsaWFzZWQgZW50cnkgaWYgaXQgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBjYWNoZSBrZXkuXG4gICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICFlbnRyeVdpdGhvdXRQYXJhbXMua2V5LmluY2x1ZGVzKElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgLi4uZW50cnlXaXRob3V0UGFyYW1zLCBhbGlhc2VkOiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgd2UgZGlkbid0IGZpbmQgYSBzcGVjaWZpYyBjYWNoZSBlbnRyeSB0aGF0IG1hdGNoZWRcbiAgLy8gdGhlIHJlcXVlc3QgVVJMLlxuICAvLyBXZSBhdHRlbXB0IGEgcGFydGlhbCBtYXRjaCBieSBjaGVja2luZyBpZiB0aGVyZSdzIGEgY2FjaGUgZW50cnkgd2l0aCB0aGUgc2FtZSBwYXRobmFtZS5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGF0IHdlIGZpbmQsIHNpbmNlIGl0IGRvZXNuJ3QgY29ycmVzcG9uZCB3aXRoIHRoZSByZXF1ZXN0ZWQgVVJMLCB3ZSdsbCBtYXJrIGl0IFwiYWxpYXNlZFwiLlxuICAvLyBUaGlzIHdpbGwgc2lnbmFsIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seSBhcHBseSB0aGUgbG9hZGluZyBzdGF0ZSBvbiB0aGUgcHJlZmV0Y2hlZCBkYXRhLlxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgIGFsbG93QWxpYXNpbmdcbiAgKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZUVudHJ5IG9mIHByZWZldGNoQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY2FjaGVFbnRyeS51cmwucGF0aG5hbWUgPT09IHVybC5wYXRobmFtZSAmJlxuICAgICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgIWNhY2hlRW50cnkua2V5LmluY2x1ZGVzKElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmNhY2hlRW50cnksIGFsaWFzZWQ6IHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZmV0Y2ggY2FjaGUgZW50cnkgaWYgb25lIGV4aXN0cy4gT3RoZXJ3aXNlIGNyZWF0ZXMgYSBuZXcgb25lIGFuZCBlbnF1ZXVlcyBhIGZldGNoIHJlcXVlc3RcbiAqIHRvIHJldHJpZXZlIHRoZSBwcmVmZXRjaCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgdXJsLFxuICBuZXh0VXJsLFxuICB0cmVlLFxuICBwcmVmZXRjaENhY2hlLFxuICBraW5kLFxuICBhbGxvd0FsaWFzaW5nID0gdHJ1ZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICdwcmVmZXRjaENhY2hlJyB8ICd0cmVlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ/OiBQcmVmZXRjaEtpbmRcbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxufSk6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkge1xuICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBnZXRFeGlzdGluZ0NhY2hlRW50cnkoXG4gICAgdXJsLFxuICAgIGtpbmQsXG4gICAgbmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlLFxuICAgIGFsbG93QWxpYXNpbmdcbiAgKVxuXG4gIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBHcmFiIHRoZSBsYXRlc3Qgc3RhdHVzIG9mIHRoZSBjYWNoZSBlbnRyeSBhbmQgdXBkYXRlIGl0XG4gICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YXR1cyA9IGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhleGlzdGluZ0NhY2hlRW50cnkpXG5cbiAgICAvLyB3aGVuIGBraW5kYCBpcyBwcm92aWRlZCwgYW4gZXhwbGljaXQgcHJlZmV0Y2ggd2FzIHJlcXVlc3RlZC5cbiAgICAvLyBpZiB0aGUgcmVxdWVzdGVkIHByZWZldGNoIGlzIFwiZnVsbFwiIGFuZCB0aGUgY3VycmVudCBjYWNoZSBlbnRyeSB3YXNuJ3QsIHdlIHdhbnQgdG8gcmUtcHJlZmV0Y2ggd2l0aCB0aGUgbmV3IGludGVudFxuICAgIGNvbnN0IHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2ggPVxuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgICBraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTFxuXG4gICAgaWYgKHN3aXRjaGVkVG9GdWxsUHJlZmV0Y2gpIHtcbiAgICAgIC8vIElmIHdlIHN3aXRjaGVkIHRvIGEgZnVsbCBwcmVmZXRjaCwgdmFsaWRhdGUgdGhhdCB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgY29udGFpbmVkIHBhcnRpYWwgZGF0YS5cbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgY2FjaGUgZW50cnkgd2FzIHNlZWRlZCB3aXRoIGZ1bGwgZGF0YSBidXQgaGFzIGEgY2FjaGUgdHlwZSBvZiBcImF1dG9cIiAoaWUgd2hlbiBjYWNoZSBlbnRyaWVzXG4gICAgICAvLyBhcmUgc2VlZGVkIGJ1dCB3aXRob3V0IGEgcHJlZmV0Y2ggaW50ZW50KVxuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmRhdGEudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0Z1bGxQcmVmZXRjaCA9XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVmZXRjaFJlc3BvbnNlLmZsaWdodERhdGEpICYmXG4gICAgICAgICAgcHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhLnNvbWUoKGZsaWdodERhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIGZyb20gdGhlIHJvb3QgYW5kIHdlIHJldHVybmVkIFJTQyBkYXRhIChzZWVkRGF0YSksIHdlIGFscmVhZHkgaGFkIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgICAgICAgIHJldHVybiBmbGlnaHREYXRhLmlzUm9vdFJlbmRlciAmJiBmbGlnaHREYXRhLnNlZWREYXRhICE9PSBudWxsXG4gICAgICAgICAgfSlcblxuICAgICAgICBpZiAoIWlzRnVsbFByZWZldGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW4gZXhwbGljaXQgcHJlZmV0Y2gga2luZCwgd2Ugd2FudCB0byBzZXQgYSB0ZW1wb3Jhcnkga2luZFxuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYXNzdW1pbmcgdGhlIHNhbWUgaW50ZW50IGFzIHRoZSBwcmV2aW91cyBlbnRyeSwgdG8gYmUgY29uc2lzdGVudCB3aXRoIGhvdyB3ZVxuICAgICAgICAgICAgLy8gbGF6aWx5IGNyZWF0ZSBwcmVmZXRjaCBlbnRyaWVzIHdoZW4gaW50ZW50IGlzIGxlZnQgdW5zcGVjaWZpZWQuXG4gICAgICAgICAgICBraW5kOiBraW5kID8/IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgd2FzIG1hcmtlZCBhcyB0ZW1wb3JhcnksIGl0IG1lYW5zIGl0IHdhcyBsYXppbHkgY3JlYXRlZCB3aGVuIGF0dGVtcHRpbmcgdG8gZ2V0IGFuIGVudHJ5LFxuICAgIC8vIHdoZXJlIHdlIGRpZG4ndCBoYXZlIHRoZSBwcmVmZXRjaCBpbnRlbnQuIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGludGVudCAoaW4gYGtpbmRgKSwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGVudHJ5IHRvIHRoZSBtb3JlIGFjY3VyYXRlIGtpbmQuXG4gICAgaWYgKGtpbmQgJiYgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPT09IFByZWZldGNoS2luZC5URU1QT1JBUlkpIHtcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0ga2luZFxuICAgIH1cblxuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCB0aGUgZXhpc3RpbmcgZW50cnkgd2UgZm91bmQgaXMgc3RpbGwgdmFsaWQsIHNvIHdlIHJldHVybiBpdC5cbiAgICByZXR1cm4gZXhpc3RpbmdDYWNoZUVudHJ5XG4gIH1cblxuICAvLyBJZiB3ZSBkaWRuJ3QgcmV0dXJuIGFuIGVudHJ5LCBjcmVhdGUgYSBuZXcgb25lLlxuICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgIHRyZWUsXG4gICAgdXJsLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBraW5kOiBraW5kIHx8IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIH0pXG59XG5cbi8qXG4gKiBVc2VkIHRvIHRha2UgYW4gZXhpc3RpbmcgY2FjaGUgZW50cnkgYW5kIHByZWZpeCBpdCB3aXRoIHRoZSBuZXh0VXJsLCBpZiBpdCBleGlzdHMuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBoYXZlIGNvbmZsaWN0aW5nIGNhY2hlIGVudHJpZXMgZm9yIHRoZSBzYW1lIFVSTCAoYXMgaXMgdGhlIGNhc2Ugd2l0aCByb3V0ZSBpbnRlcmNlcHRpb24pLlxuICovXG5mdW5jdGlvbiBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAgZXhpc3RpbmdDYWNoZUtleSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGV4aXN0aW5nQ2FjaGVLZXk6IHN0cmluZ1xufSkge1xuICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChleGlzdGluZ0NhY2hlS2V5KVxuICBpZiAoIWV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgIC8vIG5vLW9wIC0tIHRoZXJlIHdhc24ndCBhbiBlbnRyeSB0byBtb3ZlXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBuZXdDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gICAgdXJsLFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kLFxuICAgIG5leHRVcmxcbiAgKVxuICBwcmVmZXRjaENhY2hlLnNldChuZXdDYWNoZUtleSwgeyAuLi5leGlzdGluZ0NhY2hlRW50cnksIGtleTogbmV3Q2FjaGVLZXkgfSlcbiAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoZXhpc3RpbmdDYWNoZUtleSlcblxuICByZXR1cm4gbmV3Q2FjaGVLZXlcbn1cblxuLyoqXG4gKiBVc2UgdG8gc2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGUgd2l0aCBkYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBmZXRjaGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAgdXJsLFxuICBkYXRhLFxuICBraW5kLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3RyZWUnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAgZGF0YTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBraW5kOiBQcmVmZXRjaEtpbmRcbn0pIHtcbiAgLy8gVGhlIGluaXRpYWwgY2FjaGUgZW50cnkgdGVjaG5pY2FsbHkgaW5jbHVkZXMgZnVsbCBkYXRhLCBidXQgaXQgaXNuJ3QgZXhwbGljaXRseSBwcmVmZXRjaGVkIC0tIHdlIGp1c3Qgc2VlZCB0aGVcbiAgLy8gcHJlZmV0Y2ggY2FjaGUgc28gdGhhdCB3ZSBjYW4gc2tpcCBhbiBleHRyYSBwcmVmZXRjaCByZXF1ZXN0IGxhdGVyLCBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIGRhdGEuXG4gIC8vIGlmIHRoZSBwcmVmZXRjaCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgdXNlIHRoZSBuZXh0VXJsIHRvIHByZWZpeCB0aGUgY2FjaGUga2V5XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBkYXRhLmNvdWxkQmVJbnRlcmNlcHRlZFxuICAgID8gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQsIG5leHRVcmwpXG4gICAgOiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGE6IFByb21pc2UucmVzb2x2ZShkYXRhKSxcbiAgICBraW5kLFxuICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXNlZFRpbWU6IERhdGUubm93KCksXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgc3RhdHVzOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgdXJsLFxuICB9IHNhdGlzZmllcyBQcmVmZXRjaENhY2hlRW50cnlcblxuICBwcmVmZXRjaENhY2hlLnNldChwcmVmZXRjaENhY2hlS2V5LCBwcmVmZXRjaEVudHJ5KVxuXG4gIHJldHVybiBwcmVmZXRjaEVudHJ5XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByZWZldGNoIGVudHJ5IGVudHJ5IGFuZCBlbnF1ZXVlcyBhIGZldGNoIHJlcXVlc3QgdG8gcmV0cmlldmUgdGhlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgdXJsLFxuICBraW5kLFxuICB0cmVlLFxuICBuZXh0VXJsLFxuICBwcmVmZXRjaENhY2hlLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3RyZWUnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KTogUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgcHJlZmV0Y2hDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kKVxuXG4gIC8vIGluaXRpYXRlcyB0aGUgZmV0Y2ggcmVxdWVzdCBmb3IgdGhlIHByZWZldGNoIGFuZCBhdHRhY2hlcyBhIGxpc3RlbmVyXG4gIC8vIHRvIHRoZSBwcm9taXNlIHRvIHVwZGF0ZSB0aGUgcHJlZmV0Y2ggY2FjaGUgZW50cnkgd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcyAoaWYgbmVjZXNzYXJ5KVxuICBjb25zdCBkYXRhID0gcHJlZmV0Y2hRdWV1ZS5lbnF1ZXVlKCgpID0+XG4gICAgZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHtcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlOiB0cmVlLFxuICAgICAgbmV4dFVybCxcbiAgICAgIHByZWZldGNoS2luZDoga2luZCxcbiAgICB9KS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBgZmV0Y2hTZXJ2ZXJSZXNwb25zZWAgc2hvdWxkIGJlIG1vcmUgdGlnaGx5IGNvdXBsZWQgdG8gdGhlc2UgcHJlZmV0Y2ggY2FjaGUgb3BlcmF0aW9uc1xuICAgICAgLy8gdG8gYXZvaWQgZHJpZnQgYmV0d2VlbiB0aGlzIGNhY2hlIGtleSBwcmVmaXhpbmcgbG9naWNcbiAgICAgIC8vICh3aGljaCBpcyBjdXJyZW50bHkgZGlyZWN0bHkgaW5mbHVlbmNlZCBieSB0aGUgc2VydmVyIHJlc3BvbnNlKVxuICAgICAgbGV0IG5ld0NhY2hlS2V5XG5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLmNvdWxkQmVJbnRlcmNlcHRlZCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBwcmVmaXggdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXh0VXJsXG4gICAgICAgIG5ld0NhY2hlS2V5ID0gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBleGlzdGluZ0NhY2hlS2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHByZWZldGNoIHdhcyBhIGNhY2hlIGhpdCwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHRvIHJlZmxlY3QgdGhhdCBpdCB3YXMgYSBmdWxsIHByZWZldGNoLlxuICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGtub3cgdGhhdCBhIHN0YXRpYyByZXNwb25zZSB3aWxsIGNvbnRhaW4gdGhlIGZ1bGwgUlNDIHBheWxvYWQsIGFuZCBjYW4gYmUgdXBkYXRlZCB0byByZXNwZWN0IHRoZSBgc3RhdGljYFxuICAgICAgLy8gc3RhbGVUaW1lLlxuICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2UucHJlcmVuZGVyZWQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoXG4gICAgICAgICAgLy8gaWYgd2UgcHJlZml4ZWQgdGhlIGNhY2hlIGtleSBkdWUgdG8gcm91dGUgaW50ZXJjZXB0aW9uLCB3ZSB3YW50IHRvIHVzZSB0aGUgbmV3IGtleS4gT3RoZXJ3aXNlIHdlIHVzZSB0aGUgb3JpZ2luYWwga2V5XG4gICAgICAgICAgbmV3Q2FjaGVLZXkgPz8gcHJlZmV0Y2hDYWNoZUtleVxuICAgICAgICApXG4gICAgICAgIGlmIChleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IFByZWZldGNoS2luZC5GVUxMXG4gICAgICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3RhbGUgdGltZSB0aGF0IHdhcyBjb2xsZWN0ZWQgYnkgdGhlIHNlcnZlciBkdXJpbmdcbiAgICAgICAgICAgIC8vIHN0YXRpYyBnZW5lcmF0aW9uLiBVc2UgdGhpcyBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBzdGFsZSB0aW1lLlxuICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YWxlVGltZSA9IHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVmZXRjaFJlc3BvbnNlXG4gICAgfSlcbiAgKVxuXG4gIGNvbnN0IHByZWZldGNoRW50cnkgPSB7XG4gICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgZGF0YSxcbiAgICBraW5kLFxuICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXNlZFRpbWU6IG51bGwsXG4gICAgc3RhbGVUaW1lOiAtMSxcbiAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgc3RhdHVzOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgdXJsLFxuICB9XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmVQcmVmZXRjaENhY2hlKFxuICBwcmVmZXRjaENhY2hlOiBSZWFkb25seVJlZHVjZXJTdGF0ZVsncHJlZmV0Y2hDYWNoZSddXG4pIHtcbiAgZm9yIChjb25zdCBbaHJlZiwgcHJlZmV0Y2hDYWNoZUVudHJ5XSBvZiBwcmVmZXRjaENhY2hlKSB7XG4gICAgaWYgKFxuICAgICAgZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHByZWZldGNoQ2FjaGVFbnRyeSkgPT09XG4gICAgICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxuICAgICkge1xuICAgICAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoaHJlZilcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlc2UgdmFsdWVzIGFyZSBzZXQgYnkgYGRlZmluZS1lbnYtcGx1Z2luYCAoYmFzZWQgb24gYG5leHRDb25maWcuZXhwZXJpbWVudGFsLnN0YWxlVGltZXNgKVxuLy8gYW5kIGRlZmF1bHQgdG8gNSBtaW51dGVzIChzdGF0aWMpIC8gMCBzZWNvbmRzIChkeW5hbWljKVxuY29uc3QgRFlOQU1JQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUpICogMTAwMFxuXG5jb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMFxuXG5mdW5jdGlvbiBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoe1xuICBraW5kLFxuICBwcmVmZXRjaFRpbWUsXG4gIGxhc3RVc2VkVGltZSxcbiAgc3RhbGVUaW1lLFxufTogUHJlZmV0Y2hDYWNoZUVudHJ5KTogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIHtcbiAgaWYgKHN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAvLyBgc3RhbGVUaW1lYCBpcyB0aGUgdmFsdWUgc2VudCBieSB0aGUgc2VydmVyIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICAvLyBXaGVuIHRoaXMgaXMgYXZhaWxhYmxlLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9mIHRoZSBoZXVyaXN0aWNzXG4gICAgLy8gdGhhdCBmb2xsb3cuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBXaGVuIFBQUiBpcyBlbmFibGVkLCB0aGUgc2VydmVyIHdpbGwgKmFsd2F5cyogcmV0dXJuIGEgc3RhbGUgdGltZVxuICAgIC8vIHdoZW4gcHJlZmV0Y2hpbmcuIFdlIHNob3VsZCBuZXZlciB1c2UgYSBwcmVmZXRjaCBlbnRyeSB0aGF0IGhhc24ndCB5ZXRcbiAgICAvLyByZWNlaXZlZCBkYXRhIGZyb20gdGhlIHNlcnZlci4gU28gdGhlIG9ubHkgdHdvIGNhc2VzIHNob3VsZCBiZSAxKSB3ZSB1c2VcbiAgICAvLyB0aGUgc2VydmVyLWdlbmVyYXRlZCBzdGFsZSB0aW1lIDIpIHRoZSB1bnJlc29sdmVkIGVudHJ5IGlzIGRpc2NhcmRlZC5cbiAgICByZXR1cm4gRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIHN0YWxlVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gIH1cblxuICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoRGF0ZS5ub3coKSA8IChsYXN0VXNlZFRpbWUgPz8gcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgcmV0dXJuIGxhc3RVc2VkVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoXG4gIH1cblxuICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAvLyBBIHN0YWxlIGVudHJ5IHdpbGwgb25seSByZS11c2UgdGhlIGBsb2FkaW5nYCBib3VuZGFyeSwgbm90IHRoZSBmdWxsIGRhdGEuXG4gIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgXCJsYXp5IGZldGNoXCIgZm9yIHRoZSBmdWxsIGRhdGEuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuQVVUTykge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBcImZ1bGxcIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoa2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwpIHtcbiAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInBydW5lUHJlZmV0Y2hDYWNoZSIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImdldCIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJ0cmVlIiwiZXhpc3RpbmdDYWNoZUVudHJ5Iiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsImRhdGEiLCJ0aGVuIiwicHJlZmV0Y2hSZXNwb25zZSIsImlzRnVsbFByZWZldGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxpZ2h0RGF0YSIsInNvbWUiLCJpc1Jvb3RSZW5kZXIiLCJzZWVkRGF0YSIsImNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5IiwicHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkiLCJleGlzdGluZ0NhY2hlS2V5IiwibmV3Q2FjaGVLZXkiLCJzZXQiLCJkZWxldGUiLCJwcmVmZXRjaENhY2hlS2V5IiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlZmV0Y2hFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVmZXRjaFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFVzZWRUaW1lIiwic3RhbGVUaW1lIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiZnJlc2giLCJwcmVmZXRjaFF1ZXVlIiwiZW5xdWV1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoS2luZCIsInByZXJlbmRlcmVkIiwiaHJlZiIsInByZWZldGNoQ2FjaGVFbnRyeSIsImV4cGlyZWQiLCJEWU5BTUlDX1NUQUxFVElNRV9NUyIsIk51bWJlciIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FIiwiU1RBVElDX1NUQUxFVElNRV9NUyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUiLCJzdGFsZSIsInJldXNhYmxlIiwiQVVUTyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQTZIYUE7OztlQUFBQTs7O2lEQTdIdUI7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7NkNBQ0U7dUNBRUs7bURBQ0M7K0RBQ1k7QUFFbEQsd0ZBQXdGO0FBQ3hGLFNBQVNDLHNCQUNQQyxLQUEyQixFQUMzQkMsTUFBd0I7SUFFeEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CRixRQUFRRywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQUFBO0lBQ3pCLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQWlDLEVBQUNWLE1BQU1XLElBQUk7SUFFbkUsdURBQXVEO0lBQ3ZELHdDQUF3QztJQUN4Q0osTUFBTUssUUFBUSxHQUFHQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQUFBLEVBQW9CLElBQUlDLElBQUlWLE1BQU1GLFNBQVM7UUFDMURhLG1CQUFtQjtZQUFDZixNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUFFO1NBQVU7UUFDM0VLLFNBQVNQLGlCQUFpQlQsTUFBTWdCLE9BQU8sR0FBRztRQUMxQ0MsY0FBYztJQUNoQjtJQUVBLE9BQU9WLE1BQU1LLFFBQVEsQ0FBQ00sSUFBSSxDQUN4QjtZQUFDLEVBQUVDLFVBQVUsRUFBRWQsY0FBY2Usb0JBQW9CLEVBQUU7UUFDakQsNERBQTREO1FBQzVELElBQUksT0FBT0QsZUFBZSxVQUFVO1lBQ2xDLE9BQU9FLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHJCLE9BQ0FHLFNBQ0FnQixZQUNBbkIsTUFBTXNCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRGhCLE1BQU1LLFFBQVEsR0FBRztRQUVqQixJQUFJWSxjQUFjeEIsTUFBTVcsSUFBSTtRQUM1QixJQUFJYyxlQUFlekIsTUFBTU8sS0FBSztRQUU5QixLQUFLLE1BQU1tQix3QkFBd0JQLFdBQVk7WUFDN0MsTUFBTSxFQUFFUixNQUFNZ0IsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR0Y7WUFDMUMsSUFBSSxDQUFDRSxjQUFjO2dCQUNqQixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBTzlCO1lBQ1Q7WUFFQSxNQUFNK0IsVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUNkO2dCQUNDO2FBQUcsRUFDSlIsYUFDQUcsV0FDQTNCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSTBCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFBQSxFQUFzQmpDLE9BQU9DLFFBQVEwQjtZQUM5QztZQUVBLElBQUlPLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEJWLGFBQWFPLFVBQVU7Z0JBQ3JELE9BQU9WLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHJCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNWSwyQkFBMkJmLHVCQUM3QmdCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JoQix3QkFDbEJpQjtZQUVKLElBQUlqQixzQkFBc0I7Z0JBQ3hCakIsUUFBUUUsWUFBWSxHQUFHOEI7WUFDekI7WUFDQSxNQUFNRyxVQUFVQyxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBQUEsRUFDZGQsY0FDQWxCLE9BQ0FtQjtZQUdGLElBQUlZLFNBQVM7Z0JBQ1huQyxRQUFRSSxLQUFLLEdBQUdBO2dCQUNoQmtCLGVBQWVsQjtZQUNqQjtZQUVBSixRQUFRcUMsV0FBVyxHQUFHVDtZQUN0QjVCLFFBQVFFLFlBQVksR0FBR0Q7WUFFdkJvQixjQUFjTztRQUNoQjtRQUNBLE9BQU9VLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWN6QyxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVY7QUFFQSxTQUFTMEMsc0JBQ1AxQyxLQUEyQixFQUMzQjJDLE9BQXlCO0lBRXpCLE9BQU8zQztBQUNUO0FBRU8sTUFBTUYsb0JBQ1g4QyxNQUFvQixHQUNoQkYsQ0FBcUJBLEdBQ3JCM0MiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xccm91dGVyLXJlZHVjZXJcXHJlZHVjZXJzXFxobXItcmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgSG1yUmVmcmVzaEFjdGlvbixcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcblxuLy8gQSB2ZXJzaW9uIG9mIHJlZnJlc2ggcmVkdWNlciB0aGF0IGtlZXBzIHRoZSBjYWNoZSBhcm91bmQgaW5zdGVhZCBvZiB3aXBpbmcgYWxsIG9mIGl0LlxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJJbXBsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybFxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcblxuICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgY2FjaGUubGF6eURhdGEgPSBmZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwge1xuICAgIGZsaWdodFJvdXRlclN0YXRlOiBbc3RhdGUudHJlZVswXSwgc3RhdGUudHJlZVsxXSwgc3RhdGUudHJlZVsyXSwgJ3JlZmV0Y2gnXSxcbiAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICAgIGlzSG1yUmVmcmVzaDogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gY2FjaGUubGF6eURhdGEudGhlbihcbiAgICAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlIH0pID0+IHtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgY2FjaGUubGF6eURhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbFxuXG4gICAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gICAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGVcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdHJlZTogdHJlZVBhdGNoLCBpc1Jvb3RSZW5kZXIgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JFRlJFU0ggRkFJTEVEJylcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgIFsnJ10sXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlU2VnbWVudE1pc21hdGNoKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICAgID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpXG4gICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGxpZWQgPSBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIClcblxuICAgICAgICBpZiAoYXBwbGllZCkge1xuICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgICAgIH1cblxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWZcblxuICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKCkgPT4gc3RhdGVcbiAgKVxufVxuXG5mdW5jdGlvbiBobXJSZWZyZXNoUmVkdWNlck5vb3AoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgX2FjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCBobXJSZWZyZXNoUmVkdWNlciA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICA/IGhtclJlZnJlc2hSZWR1Y2VyTm9vcFxuICAgIDogaG1yUmVmcmVzaFJlZHVjZXJJbXBsXG4iXSwibmFtZXMiOlsiaG1yUmVmcmVzaFJlZHVjZXIiLCJobXJSZWZyZXNoUmVkdWNlckltcGwiLCJzdGF0ZSIsImFjdGlvbiIsIm9yaWdpbiIsIm11dGFibGUiLCJocmVmIiwiY2Fub25pY2FsVXJsIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiaW5jbHVkZU5leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0cmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwiaXNIbXJSZWZyZXNoIiwidGhlbiIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImhhbmRsZUV4dGVybmFsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwiY3VycmVudFRyZWUiLCJjdXJyZW50Q2FjaGUiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsImlzUm9vdFJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJhcHBsaWVkIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiaG1yUmVmcmVzaFJlZHVjZXJOb29wIiwiX2FjdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/app-router.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/app-router.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _stitchederror = __webpack_require__(/*! ../components/react-dev-overlay/internal/helpers/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stitched-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../components/react-dev-overlay/internal/helpers/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-error-handler.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _interceptconsoleerror = __webpack_require__(/*! ../components/globals/intercept-console-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\");\nconst onCaughtError = (err, errorInfo)=>{\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        var _errorInfo_errorBoundary, _errorInfo_componentStack;\n        const errorBoundaryComponent = errorInfo == null ? void 0 : (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n        const errorBoundaryName = (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // Log and report the error with location but without modifying the error stack\n        (0, _interceptconsoleerror.originConsoleError)('%o\\n\\n%s', err, errorLocation);\n        (0, _useerrorhandler.handleClientError)(stitchedError, []);\n    } else {}\n};\nconst onUncaughtError = (err, errorInfo)=>{\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        var _errorInfo_componentStack;\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorLocation = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // Log and report the error with location but without modifying the error stack\n        (0, _interceptconsoleerror.originConsoleError)('%o\\n\\n%s', err, errorLocation);\n        (0, _reportglobalerror.reportGlobalError)(stitchedError);\n    } else {}\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvYXBwLXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpRkFBaUY7Ozs7Ozs7Ozs7Ozs7SUFVcEVBLGFBQWE7ZUFBYkE7O0lBaURBQyxlQUFlO2VBQWZBOzs7MkNBeER5Qjs2Q0FDSjsrQ0FDQTswQ0FDRTsrQ0FDRjttREFDQztBQUU1QixNQUFNRCxnQkFBbUQsQ0FDOURFLEtBQ0FDO0lBRUEsNkVBQTZFO0lBQzdFLElBQUlDLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFtQixFQUFDRixRQUFRRyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCSCxNQUFNO0lBRXhELElBQUlJLElBQW9CLEVBQW1CO1lBQ1ZILDBCQU9HQTtRQVBsQyxNQUFNTSx5QkFBeUJOLGFBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLDJCQUFBQSxVQUFXTyxhQUFBQSxLQUFhLGdCQUF4QlAseUJBQTBCUSxXQUFXO1FBQ3BFLE1BQU1DLG9CQUVKLENBREEsMEJBQ0NILE9BQUFBLEVBRGtDLEdBQ2xDQSxJQUFBQSx1QkFBZ0NJLFdBQUFBLE1BQ2pDSiwwQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsdUJBQXdCSyxJQUFBQSxLQUN4QjtRQUVGLE1BQU1DLDRCQUE0QlosYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsNEJBQUFBLFVBQVdhLGNBQUFBLEtBQWMsZ0JBQXpCYiwwQkFBMkJjLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUt6RSxzREFEc0QsK0NBQytDO1FBQ3JHLGdHQUFnRztRQUNoR0Y7UUFMRixxQ0FBcUM7UUFDckMsTUFBTUcsVUFJSkgsQ0FBQUEsbUNBQUFBLDZCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSwwQkFBMkJJLEtBQUssQ0FBQyxvQ0FBakNKLG1DQUE2RCxFQUFFO1FBQ2pFLE1BQU1LLDJCQUEyQkYsT0FBTyxDQUFDLEVBQUUsSUFBSUEsT0FBTyxDQUFDLEVBQUUsSUFBSTtRQUU3RCxpSUFBaUk7UUFDakksTUFBTUcsdUJBQXdCLDRCQUF5QlQsb0JBQWtCO1FBQ3pFLE1BQU1VLHdCQUF3QkYsMkJBQ3pCLHNDQUFtQ0EsMkJBQXlCLGlCQUM1RDtRQUVMLE1BQU1HLGdCQUFtQkQsd0JBQXNCLE1BQUdEO1FBRWxELE1BQU1HLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCdkI7UUFDNUMsK0NBQStDO1FBQy9DLG1FQUFtRTtRQUNuRSxJQUFJQyxVQUFVYSxjQUFjLEVBQUU7O1lBQzFCUSxjQUFzQkUsZUFBZSxHQUFHdkIsVUFBVWEsY0FBYztRQUNwRTtRQUVBLCtFQUErRTtRQUMvRVcsQ0FBQUEsR0FBQUEsdUJBQUFBLGtCQUFBQSxFQUFtQixZQUFZekIsS0FBS3FCO1FBRXBDSyxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQWtCSixlQUFlLEVBQUU7SUFDckMsT0FBTyxFQUVOO0FBQ0g7QUFFTyxNQUFNdkIsa0JBQXVELENBQ2xFQyxLQUNBQztJQUVBLDZFQUE2RTtJQUM3RSxJQUFJQyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JGLFFBQVFHLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JILE1BQU07SUFFeEQsSUFBSUksSUFBb0IsRUFBbUI7WUFDUEg7UUFBbEMsTUFBTVksNEJBQTRCWixhQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSw0QkFBQUEsVUFBV2EsY0FBQUEsS0FBYyxnQkFBekJiLDBCQUEyQmMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBSXpFRjtRQUZGLHFDQUFxQztRQUNyQyxNQUFNRyxVQUNKSCxDQUFBQSxtQ0FBQUEsNkJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLDBCQUEyQkksS0FBSyxDQUFDLG9DQUFqQ0osbUNBQTZELEVBQUU7UUFDakUsTUFBTUssMkJBQTJCRixPQUFPLENBQUMsRUFBRSxJQUFJQSxPQUFPLENBQUMsRUFBRSxJQUFJO1FBRTdELGlJQUFpSTtRQUNqSSxNQUFNSyxnQkFBZ0JILDJCQUNqQixzQ0FBbUNBLDJCQUF5QixpQkFDNUQ7UUFFTCxNQUFNSSxnQkFBZ0JDLENBQUFBLEdBQUFBLGVBQUFBLHFCQUFBQSxFQUFzQnZCO1FBQzVDLCtDQUErQztRQUMvQyxtRUFBbUU7UUFDbkUsSUFBSUMsVUFBVWEsY0FBYyxFQUFFOztZQUMxQlEsY0FBc0JFLGVBQWUsR0FBR3ZCLFVBQVVhLGNBQWM7UUFDcEU7UUFFQSwrRUFBK0U7UUFDL0VXLENBQUFBLEdBQUFBLHVCQUFBQSxrQkFBQUEsRUFBbUIsWUFBWXpCLEtBQUtxQjtRQUNwQ00sQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQkw7SUFDcEIsT0FBTyxFQUVOO0FBQ0giLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRWR1YXJkb1xcc3JjXFxjbGllbnRcXHJlYWN0LWNsaWVudC1jYWxsYmFja3NcXGFwcC1yb3V0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGlzIG9ubHkgdXNlZCBpbiBhcHAgcm91dGVyIGR1ZSB0byB0aGUgc3BlY2lmaWMgZXJyb3Igc3RhdGUgaGFuZGxpbmcuXG5cbmltcG9ydCB0eXBlIHsgSHlkcmF0aW9uT3B0aW9ucyB9IGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnXG5pbXBvcnQgeyBnZXRSZWFjdFN0aXRjaGVkRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRFcnJvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy91c2UtZXJyb3ItaGFuZGxlcidcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgb3JpZ2luQ29uc29sZUVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9nbG9iYWxzL2ludGVyY2VwdC1jb25zb2xlLWVycm9yJ1xuXG5leHBvcnQgY29uc3Qgb25DYXVnaHRFcnJvcjogSHlkcmF0aW9uT3B0aW9uc1snb25DYXVnaHRFcnJvciddID0gKFxuICBlcnIsXG4gIGVycm9ySW5mb1xuKSA9PiB7XG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKGVycikgfHwgaXNOZXh0Um91dGVyRXJyb3IoZXJyKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5Q29tcG9uZW50ID0gZXJyb3JJbmZvPy5lcnJvckJvdW5kYXJ5Py5jb25zdHJ1Y3RvclxuICAgIGNvbnN0IGVycm9yQm91bmRhcnlOYW1lID1cbiAgICAgIC8vIHJlYWQgcmVhY3QgY29tcG9uZW50IGRpc3BsYXlOYW1lXG4gICAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCBhcyBhbnkpPy5kaXNwbGF5TmFtZSB8fFxuICAgICAgZXJyb3JCb3VuZGFyeUNvbXBvbmVudD8ubmFtZSB8fFxuICAgICAgJ1Vua25vd24nXG5cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lID0gZXJyb3JJbmZvPy5jb21wb25lbnRTdGFjaz8uc3BsaXQoJ1xcbicpWzFdXG5cbiAgICAvLyBNYXRjaCBjaHJvbWUgb3Igc2FmYXJpIHN0YWNrIHRyYWNlXG4gICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICAvLyByZWdleCB0byBtYXRjaCB0aGUgZnVuY3Rpb24gbmFtZSBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgICAgIC8vIGV4YW1wbGUgMTogYXQgUGFnZSAoaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjEpXG4gICAgICAvLyBleGFtcGxlIDI6IFBhZ2VAaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjFcbiAgICAgIGNvbXBvbmVudFRoYXRFcnJvcmVkRnJhbWU/Lm1hdGNoKC9cXHMrYXQgKFxcdyspXFxzK3woXFx3KylALykgPz8gW11cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUgPSBtYXRjaGVzWzFdIHx8IG1hdGNoZXNbMl0gfHwgJ1Vua25vd24nXG5cbiAgICAvLyBDcmVhdGUgZXJyb3IgbG9jYXRpb24gd2l0aCBlcnJvcmVkIGNvbXBvbmVudCBhbmQgZXJyb3IgYm91bmRhcnksIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZiBkZWZhdWx0IFJlYWN0IG9uQ2F1Z2h0RXJyb3IgaGFuZGxlci5cbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IGBJdCB3YXMgaGFuZGxlZCBieSB0aGUgPCR7ZXJyb3JCb3VuZGFyeU5hbWV9PiBlcnJvciBib3VuZGFyeS5gXG4gICAgY29uc3QgY29tcG9uZW50RXJyb3JNZXNzYWdlID0gY29tcG9uZW50VGhhdEVycm9yZWROYW1lXG4gICAgICA/IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwke2NvbXBvbmVudFRoYXRFcnJvcmVkTmFtZX0+IGNvbXBvbmVudC5gXG4gICAgICA6IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgY29tcG9uZW50cy5gXG5cbiAgICBjb25zdCBlcnJvckxvY2F0aW9uID0gYCR7Y29tcG9uZW50RXJyb3JNZXNzYWdlfSAke2Vycm9yQm91bmRhcnlNZXNzYWdlfWBcblxuICAgIGNvbnN0IHN0aXRjaGVkRXJyb3IgPSBnZXRSZWFjdFN0aXRjaGVkRXJyb3IoZXJyKVxuICAgIC8vIFRPRE86IGNoYW5nZSB0byBwYXNzaW5nIGRvd24gZXJyb3JJbmZvIGxhdGVyXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICAgIGlmIChlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHtcbiAgICAgIDsoc3RpdGNoZWRFcnJvciBhcyBhbnkpLl9jb21wb25lbnRTdGFjayA9IGVycm9ySW5mby5jb21wb25lbnRTdGFja1xuICAgIH1cblxuICAgIC8vIExvZyBhbmQgcmVwb3J0IHRoZSBlcnJvciB3aXRoIGxvY2F0aW9uIGJ1dCB3aXRob3V0IG1vZGlmeWluZyB0aGUgZXJyb3Igc3RhY2tcbiAgICBvcmlnaW5Db25zb2xlRXJyb3IoJyVvXFxuXFxuJXMnLCBlcnIsIGVycm9yTG9jYXRpb24pXG5cbiAgICBoYW5kbGVDbGllbnRFcnJvcihzdGl0Y2hlZEVycm9yLCBbXSlcbiAgfSBlbHNlIHtcbiAgICBvcmlnaW5Db25zb2xlRXJyb3IoZXJyKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvblVuY2F1Z2h0RXJyb3I6IEh5ZHJhdGlvbk9wdGlvbnNbJ29uVW5jYXVnaHRFcnJvciddID0gKFxuICBlcnIsXG4gIGVycm9ySW5mb1xuKSA9PiB7XG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKGVycikgfHwgaXNOZXh0Um91dGVyRXJyb3IoZXJyKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lID0gZXJyb3JJbmZvPy5jb21wb25lbnRTdGFjaz8uc3BsaXQoJ1xcbicpWzFdXG5cbiAgICAvLyBNYXRjaCBjaHJvbWUgb3Igc2FmYXJpIHN0YWNrIHRyYWNlXG4gICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lPy5tYXRjaCgvXFxzK2F0IChcXHcrKVxccyt8KFxcdyspQC8pID8/IFtdXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWROYW1lID0gbWF0Y2hlc1sxXSB8fCBtYXRjaGVzWzJdIHx8ICdVbmtub3duJ1xuXG4gICAgLy8gQ3JlYXRlIGVycm9yIGxvY2F0aW9uIHdpdGggZXJyb3JlZCBjb21wb25lbnQgYW5kIGVycm9yIGJvdW5kYXJ5LCB0byBtYXRjaCB0aGUgYmVoYXZpb3Igb2YgZGVmYXVsdCBSZWFjdCBvbkNhdWdodEVycm9yIGhhbmRsZXIuXG4gICAgY29uc3QgZXJyb3JMb2NhdGlvbiA9IGNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZVxuICAgICAgPyBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JHtjb21wb25lbnRUaGF0RXJyb3JlZE5hbWV9PiBjb21wb25lbnQuYFxuICAgICAgOiBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMuYFxuXG4gICAgY29uc3Qgc3RpdGNoZWRFcnJvciA9IGdldFJlYWN0U3RpdGNoZWRFcnJvcihlcnIpXG4gICAgLy8gVE9ETzogY2hhbmdlIHRvIHBhc3NpbmcgZG93biBlcnJvckluZm8gbGF0ZXJcbiAgICAvLyBJbiBkZXZlbG9wbWVudCBtb2RlLCBwYXNzIGFsb25nIHRoZSBjb21wb25lbnQgc3RhY2sgdG8gdGhlIGVycm9yXG4gICAgaWYgKGVycm9ySW5mby5jb21wb25lbnRTdGFjaykge1xuICAgICAgOyhzdGl0Y2hlZEVycm9yIGFzIGFueSkuX2NvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrXG4gICAgfVxuXG4gICAgLy8gTG9nIGFuZCByZXBvcnQgdGhlIGVycm9yIHdpdGggbG9jYXRpb24gYnV0IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBlcnJvciBzdGFja1xuICAgIG9yaWdpbkNvbnNvbGVFcnJvcignJW9cXG5cXG4lcycsIGVyciwgZXJyb3JMb2NhdGlvbilcbiAgICByZXBvcnRHbG9iYWxFcnJvcihzdGl0Y2hlZEVycm9yKVxuICB9IGVsc2Uge1xuICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycilcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9uQ2F1Z2h0RXJyb3IiLCJvblVuY2F1Z2h0RXJyb3IiLCJlcnIiLCJlcnJvckluZm8iLCJpc0JhaWxvdXRUb0NTUkVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJlcnJvckJvdW5kYXJ5Q29tcG9uZW50IiwiZXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lIiwiY29tcG9uZW50U3RhY2siLCJzcGxpdCIsIm1hdGNoZXMiLCJtYXRjaCIsImNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tcG9uZW50RXJyb3JNZXNzYWdlIiwiZXJyb3JMb2NhdGlvbiIsInN0aXRjaGVkRXJyb3IiLCJnZXRSZWFjdFN0aXRjaGVkRXJyb3IiLCJfY29tcG9uZW50U3RhY2siLCJvcmlnaW5Db25zb2xlRXJyb3IiLCJoYW5kbGVDbGllbnRFcnJvciIsInJlcG9ydEdsb2JhbEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/shared.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/shared.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This module can be shared between both pages router and app router\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"onRecoverableError\", ({\n    enumerable: true,\n    get: function() {\n        return onRecoverableError;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _stitchederror = __webpack_require__(/*! ../components/react-dev-overlay/internal/helpers/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stitched-error.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../lib/is-error */ \"(app-pages-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst onRecoverableError = (error, errorInfo)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    const cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    const stitchedError = (0, _stitchederror.getReactStitchedError)(cause);\n    // In development mode, pass along the component stack to the error\n    if ( true && errorInfo.componentStack) {\n        ;\n        stitchedError._componentStack = errorInfo.componentStack;\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    (0, _reportglobalerror.reportGlobalError)(stitchedError);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=shared.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvc2hhcmVkLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFFQUFxRTs7Ozs7c0RBUXhEQTs7O2VBQUFBOzs7OzBDQUx1QjsrQ0FDRjsyQ0FDSTs4RUFDbEI7QUFFYixNQUFNQSxxQkFBNkQsQ0FDeEVDLE9BQ0FDO0lBRUEsc0RBQXNEO0lBQ3RELE1BQU1DLFFBQVFDLENBQUFBLEdBQUFBLFNBQUFBLE9BQUFBLEVBQVFILFVBQVUsV0FBV0EsUUFBUUEsTUFBTUUsS0FBSyxHQUFHRjtJQUNqRSxNQUFNSSxnQkFBZ0JDLENBQUFBLEdBQUFBLGVBQUFBLHFCQUFBQSxFQUFzQkg7SUFDNUMsbUVBQW1FO0lBQ25FLElBQUlJLEtBQW9CLElBQXNCTCxVQUFVUSxjQUFjLEVBQUU7O1FBQ3BFTCxjQUFzQk0sZUFBZSxHQUFHVCxVQUFVUSxjQUFjO0lBQ3BFO0lBQ0EsNkVBQTZFO0lBQzdFLElBQUlFLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFBQSxFQUFvQlQsUUFBUTtJQUVoQ1UsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQlI7QUFDcEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRWR1YXJkb1xcc3JjXFxjbGllbnRcXHJlYWN0LWNsaWVudC1jYWxsYmFja3NcXHNoYXJlZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIG1vZHVsZSBjYW4gYmUgc2hhcmVkIGJldHdlZW4gYm90aCBwYWdlcyByb3V0ZXIgYW5kIGFwcCByb3V0ZXJcblxuaW1wb3J0IHR5cGUgeyBIeWRyYXRpb25PcHRpb25zIH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgZ2V0UmVhY3RTdGl0Y2hlZEVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9oZWxwZXJzL3N0aXRjaGVkLWVycm9yJ1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vbGliL2lzLWVycm9yJ1xuXG5leHBvcnQgY29uc3Qgb25SZWNvdmVyYWJsZUVycm9yOiBIeWRyYXRpb25PcHRpb25zWydvblJlY292ZXJhYmxlRXJyb3InXSA9IChcbiAgZXJyb3IsXG4gIGVycm9ySW5mb1xuKSA9PiB7XG4gIC8vIHgtcmVmOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yODczNlxuICBjb25zdCBjYXVzZSA9IGlzRXJyb3IoZXJyb3IpICYmICdjYXVzZScgaW4gZXJyb3IgPyBlcnJvci5jYXVzZSA6IGVycm9yXG4gIGNvbnN0IHN0aXRjaGVkRXJyb3IgPSBnZXRSZWFjdFN0aXRjaGVkRXJyb3IoY2F1c2UpXG4gIC8vIEluIGRldmVsb3BtZW50IG1vZGUsIHBhc3MgYWxvbmcgdGhlIGNvbXBvbmVudCBzdGFjayB0byB0aGUgZXJyb3JcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGVycm9ySW5mby5jb21wb25lbnRTdGFjaykge1xuICAgIDsoc3RpdGNoZWRFcnJvciBhcyBhbnkpLl9jb21wb25lbnRTdGFjayA9IGVycm9ySW5mby5jb21wb25lbnRTdGFja1xuICB9XG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKGNhdXNlKSkgcmV0dXJuXG5cbiAgcmVwb3J0R2xvYmFsRXJyb3Ioc3RpdGNoZWRFcnJvcilcbn1cbiJdLCJuYW1lcyI6WyJvblJlY292ZXJhYmxlRXJyb3IiLCJlcnJvciIsImVycm9ySW5mbyIsImNhdXNlIiwiaXNFcnJvciIsInN0aXRjaGVkRXJyb3IiLCJnZXRSZWFjdFN0aXRjaGVkRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb21wb25lbnRTdGFjayIsIl9jb21wb25lbnRTdGFjayIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJyZXBvcnRHbG9iYWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/shared.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HeadManagerContext\", ({\n    enumerable: true,\n    get: function() {\n        return HeadManagerContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst HeadManagerContext = _react.default.createContext({});\nif (true) {\n    HeadManagerContext.displayName = 'HeadManagerContext';\n} //# sourceMappingURL=head-manager-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEscUJBVVJDLE9BQUFBLE9BQUssQ0FBQ0MsYUFBYSxDQUFDO0FBRXpCLElBRjBCLElBRUYsRUFBbUI7SUFDekNGLG1CQUFtQk0sV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEVkdWFyZG9cXHNyY1xcc2hhcmVkXFxsaWJcXGhlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDx7XG4gIHVwZGF0ZUhlYWQ/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBtb3VudGVkSW5zdGFuY2VzPzogYW55XG4gIHVwZGF0ZVNjcmlwdHM/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBzY3JpcHRzPzogYW55XG4gIGdldElzU3NyPzogKCkgPT4gYm9vbGVhblxuXG4gIC8vIFVzZWQgaW4gYXBwIGRpcmVjdG9yeSwgdG8gcmVuZGVyIHNjcmlwdCB0YWdzIGFzIHNlcnZlciBjb21wb25lbnRzLlxuICBhcHBEaXI/OiBib29sZWFuXG4gIG5vbmNlPzogc3RyaW5nXG59PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEhlYWRNYW5hZ2VyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIZWFkTWFuYWdlckNvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiSGVhZE1hbmFnZXJDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PathParamsContext: function() {\n        return PathParamsContext;\n    },\n    PathnameContext: function() {\n        return PathnameContext;\n    },\n    SearchParamsContext: function() {\n        return SearchParamsContext;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst SearchParamsContext = (0, _react.createContext)(null);\nconst PathnameContext = (0, _react.createContext)(null);\nconst PathParamsContext = (0, _react.createContext)(null);\nif (true) {\n    SearchParamsContext.displayName = 'SearchParamsContext';\n    PathnameContext.displayName = 'PathnameContext';\n    PathParamsContext.displayName = 'PathParamsContext';\n} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFPYUEsaUJBQWlCO2VBQWpCQTs7SUFEQUMsZUFBZTtlQUFmQTs7SUFEQUMsbUJBQW1CO2VBQW5CQTs7O21DQUhpQjtBQUd2QixNQUFNQSxzQkFBc0JDLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQXNDO0FBQ2xFLE1BQU1GLGtCQUFrQkUsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBNkI7QUFDckQsTUFBTUgsb0JBQW9CRyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUE2QjtBQUU5RCxJQUZhSCxJQUVXLEVBQW1CO0lBQ3pDRSxvQkFBb0JLLFdBQVcsR0FBRztJQUNsQ04sZ0JBQWdCTSxXQUFXLEdBQUc7SUFDOUJQLGtCQUFrQk8sV0FBVyxHQUFHO0FBQ2xDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEVkdWFyZG9cXHNyY1xcc2hhcmVkXFxsaWJcXGhvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuZXhwb3J0IGNvbnN0IFNlYXJjaFBhcmFtc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVSTFNlYXJjaFBhcmFtcyB8IG51bGw+KG51bGwpXG5leHBvcnQgY29uc3QgUGF0aG5hbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxzdHJpbmcgfCBudWxsPihudWxsKVxuZXhwb3J0IGNvbnN0IFBhdGhQYXJhbXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxQYXJhbXMgfCBudWxsPihudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1NlYXJjaFBhcmFtc0NvbnRleHQnXG4gIFBhdGhuYW1lQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdQYXRobmFtZUNvbnRleHQnXG4gIFBhdGhQYXJhbXNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1BhdGhQYXJhbXNDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIlBhdGhQYXJhbXNDb250ZXh0IiwiUGF0aG5hbWVDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\n"));

/***/ })

});